---
title: 数组
tags: [算法]      #添加的标签
categories: 算法
description: 
---



**数组是存放在连续内存空间上的相同类型数据的集合。**

需要两点注意的是

- 数组下标都是从0开始的。

- 数组内存空间的地址是连续的

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

**数组的元素是不能删的，只能覆盖。**



## 二分查找

**只要看到给出的数组是有序数组，都可以想一想是否可以使用二分法**



### 搜索插入的位置

Leetcode：35.搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

```go
func searchInsert(nums []int, target int) int {
    left := 0
    right := len(nums) - 1

    for left <= right {	// 区间是左闭右闭
        mid := left + ((right - left)/2)
        if nums[mid] < target{
            left = mid + 1
        } else if nums[mid] > target{
            right = mid - 1
        } else {
            return mid
        }
    }
    // 分别处理如下四种情况
    // 目标值在数组所有元素之前  [0, -1]
    // 目标值等于数组中某一个元素  return middle;
    // 目标值插入数组中的位置 [left, right]，return  right + 1
    // 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1
    return right + 1
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)



### 在排序数组中查找元素的第一个和最后一个位置



### X的平方根

Leetcode：69.x 的平方根 

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**



思路：二分法，由于平方根一定小于它的一半，所以右边界可以减半；其次，由于与插入元素是插入边界右边，所以需要`return right + 1`，而平方根要求保留整数部分 ，小数部分将被舍去，所以是`return right`

```go
func mySqrt(x int) int {
    if x < 2 {
        return x
    }

    left := 0
    right := x >> 1 // 平方根一定小于它的一半

    for left <= right {
        mid := left + (right - left) >> 1
        if mid*mid > x {
            right = mid - 1
        } else if mid*mid < x {
            left = mid + 1
        } else {
            return mid
        }
    }
    return right
}
```



## 双指针法

双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置



### 移除元素

Leetcode：27.移除元素

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。



思路：

1. 暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。但是这样的时间复杂度：O(n^2)。

2. 双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

   ```go
   func removeElement(nums []int, val int) int {
       slow := 0
       for fast := 0; fast < len(nums); fast++ {
           // 满足条件，就执行更新操作
           if nums[fast] != val {
               nums[slow] = nums[fast]	// 移动元素，往前覆盖
               slow++	// 注意此处的slow++是放在上面移动元素之后的，因为是要删除元素，所以先移动元素，再slow++
           }
       }
       return slow
   }
   ```

   - 时间复杂度：O(n)
   - 空间复杂度：O(1)





### 删除有序数组中的重复项

Leetcode：26.删除有序数组中的重复项

给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素 ***\*只出现一次\**** ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地***\*修改输入数组\**** 并在使用 O(1) 额外空间的条件下完成。

示例 1：

输入：nums = [1,1,2]

输出：2, nums = [1,2]

解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。



思路：双指针法，与移除元素题目不同，**此处的`slow++`需要在移动元素代码（`nums[slow] = nums[fast]`）之前执行，因为是删除重复项，所以`slow++`后相同元素就保留下来一个**。

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    slow := 0

    for fast := 0; fast < len(nums); fast++ {
        if nums[fast] != nums[slow] {
            slow++	// 先slow++，保留下重复项中的一个元素
            nums[slow] = nums[fast]
        }
    }

    return slow + 1
}
```





### 移动零

Leetcode：283.移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```



```go
func moveZeroes(nums []int)  {
    slow := 0

    for fast := 0; fast < len(nums); fast++ {
        if nums[fast] != 0 { // 快指针不为0时，就与慢指针进行交换元素
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow++
        }
    }
}
```





### 比较含退格的字符串

Leetcode：844.比较含退格的字符串

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```



思路：

```go
func backspaceCompare(s string, t string) bool {
    return process(s) == process(t)
}

func process(str string) string{
    stk := []byte{} // 模拟栈

    for fast := 0; fast < len(str); fast++ {
        if str[fast] != '#' {
            stk = append(stk, str[fast])
        } else if len(stk) > 0 { // 等于'#'，就从栈中弹出一个字符
            stk = stk[:len(stk) - 1]
        }
    }

    return string(stk)
}
```







**什么时候使用双指针，问GPT**
