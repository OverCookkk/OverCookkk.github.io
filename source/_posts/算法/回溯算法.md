---
title: 回溯算法
tags: [算法]      #添加的标签
categories: 算法
description: 
---

## 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等



**组合是不强调元素顺序的，排列是强调元素顺序**。

例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。

回溯模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

- 回溯搜索的遍历过程

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：![回溯算法示意图](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png)



- 关于递归传参startIndex问题

  （1）一个集合中的元素不能重复选取类型（递归参数需要传入startIndex，表示下一轮递归遍历的起始位置）

  **每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex递归的参数）**

  （2）**多个集合**中的元素不能重复选取类型。（不需要startIndex）

  （3）一个集合中的元素可以无限重复选取，但是有总和的限制。（需要startIndex，但是可以重复读取当前的数，所以递归的时候传参i）

  （4）一个集合中的元素只能使用一次，并且数组是有重复的元。（需要startIndex，并且要先排序数组，然后进行剪枝）



- **剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了**。
- **在求和问题中，排序之后加剪枝是常见的套路！**



## 组合问题

### 组合（单集合问题）

Leetcode：77.组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

思路：**要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题**。

递归来做层叠嵌套（可以理解是写k层for循环），**每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**。

```go
var ( 
    path []int
    result [][]int
)

func combine(n int, k int) [][]int {
    path, result = make([]int, 0, k), make([][]int, 0)
    backtracking(n, k, 1)   // 因为n从1开始，索引startIndex传1
    return result
}

func backtracking(n, k, startIndex int) {
    if len(path) == k {
        tmp := make([]int, k)   // path需要重复使用，go中要拷贝一份
        copy(tmp, path)
        result = append(result, tmp)
        return
    }

    for i := startIndex; i <= n; i++ {  // 从startIndex开始，不往回走，避免出现重复组合
        if n - i + len(path) + 1 < k {  // 剪枝
            break
        }
        path = append(path, i)      // 处理
        backtracking(n, k, i+1)     // 递归，纵向遍历，已经取过i了，所以下一层从i+1开始往后取数
        path = path[:len(path)-1]   // 回溯，撤销处理的节点
    }
}
```

- 时间复杂度: O(n * 2^n)
- 空间复杂度: O(n)



### 组合总和III（单集合问题）

Leetcode：216.组合总和III

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

- 所有数字都是正整数。
- 解集不能包含重复的组合。

示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]

示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]



```go
var (
    path []int
    res [][]int
)

func combinationSum3(k int, n int) [][]int {
    path, res = make([]int, 0, k), make([][]int, 0)
    backtracking(n, k, 0, 1)
    return res
}

// 一个集合中的元素不能重复选取类型（递归参数需要传入startIndex，表示下一轮递归遍历的起始位置）
func backtracking(n, k, sum, startIndex int) {
    if sum == n && len(path) == k {		// 两个条件，总和 和 个数
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
        return
    }

    for i := startIndex; i <= 9; i++ {
        if 9 - i + len(path) + 1 < k || sum + i > n {	// 剪枝
            break
        }
        path = append(path, i)
        sum += i
        backtracking(n, k, sum, i+1)
        path = path[:len(path)-1]   // 回溯
        sum -= i                    // 回溯
    }
}
```

- 时间复杂度: O(n * 2^n)
- 空间复杂度: O(n)



### 电话号码的字母组合（多集合问题）

Leetcode：17.电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射与电话按键相同。注意 1 不对应任何字母。

示例:

- 输入："23"
- 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].

说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。



思路：因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，与之前在同一个集合中的求组合不同。所以注意这里for循环是从0开始的，并不是从startIndex的；当前中的index代表digits中的第几个数字。

```go
var (
    m []string
    path []byte
    res []string
)

func letterCombinations(digits string) []string {
    // 前两个分别代表0和1
    m = []string{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
    path, res = make([]byte, 0, len(digits)), make([]string, 0)

    if digits == "" {
        return res
    }
    backtracking(digits, 0) // 0代表digits从第0个值开始取
    return res
}

func backtracking(digits string, index int) {
    if len(path) == len(digits) {
        tmp := make([]byte, len(path))
        copy(tmp, path)
        res = append(res, string(tmp))
        return
    }

    digit := digits[index] - '0'	// 转换为0-9
    str := m[digit]

    for i := 0; i < len(str); i++ {
        path = append(path, str[i])
        backtracking(digits, index+1)
        path = path[:len(path)-1]
    }
}
```

- 时间复杂度: O(3^m * 4^n)，其中 m 是对应四个字母的数字个数，n 是对应三个字母的数字个数
- 空间复杂度: O(3^m * 4^n)





### 组合总和

Leetcode：39.组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

示例 1：

- 输入：candidates = [2,3,6,7], target = 7,
- 所求解集为： [ [7], [2,2,3] ]

示例 2：

- 输入：candidates = [2,3,5], target = 8,
- 所求解集为： [ [2,2,2,2], [2,3,3], [3,5] ]



思路分析：与前面组合问题一样，唯一不同的地方在于**集合中的数字可以无限制重复被选取**，所以需要用到startIndex，但是递归传参时传递的不是`i+1`，而是`i`，传递`i`，代表可以重复选择集合中的元素；其次，**在求和问题中，排序之后加剪枝是常见的套路！**，所以还需要在递归前进行排序。

```go
var ( 
    path []int
    res [][]int
)

func combinationSum(candidates []int, target int) [][]int {
    path, res = make([]int, 0, len(candidates)), make([][]int, 0)
    sort.Ints(candidates)   // 排序，为剪枝做准备
    backtracking(candidates, 0, target, 0)
    return res
}

func backtracking(candidates []int, sum, target int, startIndex int) {
    if sum > target {   // 剪枝
        return
    }
    if sum == target {
        tmp := make([]int, len(path))
        copy(tmp, path)
        res = append(res, tmp)
        return
    }

    for i := startIndex; i < len(candidates); i++ {
        path = append(path, candidates[i])
        sum += candidates[i]
        backtracking(candidates, sum, target, i)    // 不用i+1了，表示可以重复读取当前的数
        path = path[:len(path)-1]
        sum -= candidates[i]
    }
}

```

- 时间复杂度: O(n * 2^n)，注意这只是复杂度的上界，因为剪枝的存在，真实的时间复杂度远小于此
- 空间复杂度: O(target)





### 组合总和 II

Leetcode：40.组合总和 II

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```



思路：本类型题目与前面题目区别在于**集合（数组candidates）有重复元素，但还不能有重复的组合**。
