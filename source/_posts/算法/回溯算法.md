---
title: 回溯算法
tags: [算法]      #添加的标签
categories: 算法
description: 
---

## 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等



**组合是不强调元素顺序的，排列是强调元素顺序**。

例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。

回溯模板

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

- 回溯搜索的遍历过程

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：![回溯算法示意图](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png)



## 组合问题

### 组合

Leetcode：77.组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

思路：**要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题**。

递归来做层叠嵌套（可以理解是写k层for循环），**每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**。

```go
var (
    path []int
    result [][]int
)

func combine(n int, k int) [][]int {
    path, result = make([]int, 0, k), make([][]int, 0)
    backtracking(n, k, 1)   // n从1开始，索引startIndex传1
    return result
}

func backtracking(n, k, startIndex int) {
    if len(path) == k {
        tmp := make([]int, k)   // path需要重复使用，go中要拷贝一份
        copy(tmp, path)
        result = append(result, tmp)
        return
    }

    for i := startIndex; i <= n; i++ {  // 从startIndex开始，不往回走，避免出现重复组合
        if n - i + len(path) + 1 < k {  // 剪枝
            break
        }
        path = append(path, i)      // 处理
        backtracking(n, k, i+1)     // 递归，纵向遍历，已经取过i了，所以下一层从i+1开始往后取数
        path = path[:len(path)-1]   // 回溯
    }
}
```

