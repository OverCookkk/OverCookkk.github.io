---
title: go的协程调度器原理及GMP设计思想
tags: [go]      #添加的标签
categories: 
  - GO
description: 
cover: 
---



## Golang“调度器”的由来

### 单进程时代不需要调度器

我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”

一切的程序只能串行发生。

![早期单进程操作系统](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E6%97%A9%E6%9C%9F%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)

早期的单进程操作系统，面临2个问题：

1. 单一的执行流程，计算机只能一个任务一个任务处理。

2. 进程阻塞所带来的CPU时间浪费。

那么能不能有多个进程来宏观一起来执行多个任务呢？

后来操作系统就具有了**最早的并发能力：多进程并发**，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。



### 多进程/线程时代有了调度器需求

![多线程、多进程操作系统](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)

在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。

但新的问题就又出现了，**进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间**，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。

**怎么才能提高CPU的利用率呢？**

但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。

![cpu切换进程消耗成本](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/cpu%E5%88%87%E6%8D%A2%E8%BF%9B%E7%A8%8B%E6%B6%88%E8%80%97%E6%88%90%E6%9C%AC.png)

很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。



### 用协程来提高CPU利用率

多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。

大量的进程/线程出现了新的问题

- 高内存占用：每个线程都有个固定大小的栈空间，与线程相比，协程的栈空间通常更小，Go runtime会动态地调整协程的栈大小，以适应实际需要。
- 创建和销毁开销大：创建和销毁线程需要进行一系列的操作，如分配内存、初始化线程控制块等。而协程的创建和销毁开销相对较小，因为它们只需要分配一些额外的内存来保存状态和上下文信息，并且可以重复使用已经存在的协程。
- 线程调度开销大：线程的调度通常由操作系统内核完成，涉及上下文切换和内核态与用户态之间的切换。相比之下，协程的调度是由Go运行时的调度器在用户态完成的，避免了频繁的内核态切换，从而减少了调度开销。

好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。

一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。



协程和线程的映射关系有N:1、1:1、M:N

1. N个协程绑定1个线程

   优点：**协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速**。

   缺点：

   - 某个程序用不了硬件的多核加速能力
   - 一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。

2. 1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，

   缺点：

   - 协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。

3. M个协程绑定1个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。![线程与协程M比N关系](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8BM%E6%AF%94N%E5%85%B3%E7%B3%BB.png)



### Go语言的协程goroutine

**Go为了提供更容易使用的并发方法，使用了goroutine和channel**。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。

Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，`runtime`会自动为goroutine分配。

Goroutine特点：

- 占用内存更小（几kb）
- 调度更灵活(runtime调度)



## Goroutine调度器的GMP模型的设计思想

G表示Goroutine，M表示线程，P（Processor）表示调度器

**Processor，它包含了运行goroutine的资源**，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。

### GMP模型

在Go中，**线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上**。

![go中的GMP模型](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/go%E4%B8%AD%E7%9A%84GMP%E6%A8%A1%E5%9E%8B.png)

1. **全局队列**（Global Queue）：存放等待运行的G。
2. **P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3. **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`(可配置)个。
4. **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

**Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行**。



### 调度器的设计策略

**复用线程**：避免频繁的创建、销毁线程，而是对线程的复用。

- work stealing机制：当本线程无可运行的G时，尝试从其他线程绑定的P**偷取**G，而不是销毁线程。

- hand off机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P**转移**给其他空闲的线程执行。

**利用并行**：`GOMAXPROCS`设置P的数量，最多有`GOMAXPROCS`个线程分布在多个CPU上同时运行。`GOMAXPROCS`也限制了并发的程度，比如`GOMAXPROCS = 核数/2`，则最多利用了一半的CPU核进行并行。

**抢占**：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。

**全局G队列**：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。



### go func() 调度流程

![go中go func()调度流程](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/go%E4%B8%ADgo%20func()%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png)

流程：

 1、通过 go func()来创建一个goroutine；

 2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；

 3、G只能运行在M中，一个M必须持有一个P，**M与P是1：1的关系**。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；

 4、一个M调度G执行的过程是一个循环机制；

 5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；

 6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。



### 调度器的生命周期

M0：

启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作（创建P和P队列、全局队列等）和启动第一个G（一般就是main），在这之后M0和其他M一样

G0：

G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度G（G0在M的结构体里），G0不指向任何可执行的函数，每个M都会有一个自己的G0。在调度或系统调用的时候会使用G0的栈空间，全局变量的G0是M0的G0

执行main.go流程：

![go中执行main的调度流程](https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/go%E4%B8%AD%E6%89%A7%E8%A1%8Cmain%E7%9A%84%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png)

