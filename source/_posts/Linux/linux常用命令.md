---
title: linux常用命令
tags: [linux]      #添加的标签
categories: Linux
description: 主要介绍常用的linux命令
cover: https://raw.githubusercontent.com/OverCookkk/PicBed/master/blog_cover_images/391061.jpeg
---



## grep

grep 命令用于查找文件里符合条件的字符串。

查找到符合的内容，就会把含有符合内容的那一列显示出来。

```bash
grep "文件内容" 文件名
```

**参数**：

- **-a 或 --text** : 不要忽略二进制的数据。
- **-A<显示行数> 或 --after-context=<显示行数>** : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。
- **-b 或 --byte-offset** : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。
- **-B<显示行数> 或 --before-context=<显示行数>** : 除了显示符合样式的那一行之外，并显示该行之前的内容。
- **-c 或 --count** : 计算符合样式的列数。
- **-C<显示行数> 或 --context=<显示行数>或-<显示行数>** : 除了显示符合样式的那一行之外，并显示该行之前后的内容。
- **-d <动作> 或 --directories=<动作>** : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
- **-e<范本样式> 或 --regexp=<范本样式>** : 指定字符串做为查找文件内容的样式。
- **-E 或 --extended-regexp** : 将样式为延伸的正则表达式来使用。
- **-f<规则文件> 或 --file=<规则文件>** : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
- **-F 或 --fixed-regexp** : 将样式视为固定字符串的列表。
- **-G 或 --basic-regexp** : 将样式视为普通的表示法来使用。
- **-h 或 --no-filename** : 在显示符合样式的那一行之前，不标示该行所属的文件名称。
- **-H 或 --with-filename** : 在显示符合样式的那一行之前，表示该行所属的文件名称。
- **-i 或 --ignore-case** : 忽略字符大小写的差别。
- **-l 或 --file-with-matches** : 列出文件内容符合指定的样式的文件名称。
- **-L 或 --files-without-match** : 列出文件内容不符合指定的样式的文件名称。
- **-n 或 --line-number** : 在显示符合样式的那一行之前，标示出该行的列数编号。
- **-o 或 --only-matching** : 只显示匹配PATTERN 部分。
- **-q 或 --quiet或--silent** : 不显示任何信息。
- **-r 或 --recursive** : 此参数的效果和指定"-d recurse"参数相同。
- **-s 或 --no-messages** : 不显示错误信息。
- **-v 或 --invert-match** : 显示不包含匹配文本的所有行。
- **-V 或 --version** : 显示版本信息。
- **-w 或 --word-regexp** : 只显示全字符合的列。
- **-x --line-regexp** : 只显示全列符合的列。
- **-y** : 此参数的效果和指定"-i"参数相同。



此外，如果想要搜索以某些字符结尾的字段，可以加上`$`符号匹配结尾，如：

```bash
grep "xxx.conf$" *
```



## awk

格式：

```bash
awk [option] '{pattern[action]}' {filenames}   # 行匹配语句 awk '' 只能用单引号\
#awk 参数 '{模式[条件动作]}' 文件
```

- Action指的是动作，awk擅长文本格式化，且输出格式化后的结果，因此最常用的动作就是**打印动作**`print`和`printf`



### awk场景

```test
cat test
#Fields:id      language        language_id     language_name
7       en      1       英语
8       hu      2       匈牙利语
9       fr      4       法语
10      ro      8       罗马尼亚语
11      it      16      意大利语
12      id      32      印度尼西亚语
13      es      64      西班牙语
```

执行命令`awk '{print $1} test'`，结果输出第一列信息。

```test
7
8
9
......
```

awk默认以**空格**为分隔符，且多个空格也识别为一个空格，作为分隔符；

awk是**按行处理文件**，一行处理完毕，接着处理下一行，根据用户指定的分隔符去工作，没有指定则默认空格。

- `$0`表示整行，又因为awk按行处理，所以`print $0`会输出全部内容，`$1`表示第一列。
- `$(NF)`表示当前分割后的最后一列，`$(NF-1)`表示倒数第二列（必须要加上括号）。



### awk内置变量

| 内置变量              | 解释                              |
| --------------------- | --------------------------------- |
| $n                    | 指定分隔符后，当前记录的第n个字段 |
| $0                    | 完整的输入记录                    |
| FS                    | 字段分隔符，默认是空格            |
| $NF(number of fields) | 分割后，当前行一共有多少个字段    |
| NR(number of records) | 当前记录数，行数                  |

- awk的内置变量NR、NF是不用添加$符号的，而要取出该列对应的内容时候，才需要加$符号



### 自定义输出内容

awk，必须`外层单引号`，`内容双引号`

内置变量`$1`，`$2`都不能添加双引号，否则会识别为文本，尽量别加引号；此外这两个内置变量之间的**逗号**会使得输出以空格为分隔符，不加逗号会没有分隔符。

1. 自定义输出第N列内容

   ```test
   $ awk '{print "第一列:"$1,"第二列："$2 }' test
   第一列:#Fields:id 第二列：language
   第一列:7 第二列：en
   第一列:8 第二列：hu
   .....
   ```

2. 自定义输出文件m~n行内容：设置  模式(条件)

   ```text
   $ awk 'NR==2,NR==5{print $0}' test
   7       en      1       英语
   8       hu      2       匈牙利语
   9       fr      4       法语
   10      ro      8       罗马尼亚语
   ```
   
3. 给每一行的内容添加行号：添加遍历，NR等于行号，$0表示一整行内容

   ```text
   $ awk '{print NR,$0}' test
   1 #Fields:id    language        language_id     language_name
   2 7     en      1       英语
   3 8     hu      2       匈牙利语
   4 9     fr      4       法语
   ......
   ```



### awk参数

| 参数 | 解释                        |
| ---- | --------------------------- |
| -F   | 指定分隔字段符              |
| -v   | 定义或修改一个awk内部的变量 |
| -f   | 从脚本文件中读取awk命令     |

1. FS（field separator）输入分隔符：通过`-F`参数修改输入的分隔符。

   （假设test文本里的字段都是用`:`分隔的）

   ```text
   $ awk -F ":" '{print $1,$(NF-1),$4}' test
   #Fields language_id language_id
   #7 1 英语
   #8 2 匈牙利语
   #9 4 法语
   #10 8 罗马尼亚语
   ```

2. OFS(output field separator)输出分隔符：通过`-v`来修改输出内容的分隔符，`$1,$NF`之间加上逗号，本应是用空格分隔输出内容，但是通过`-v OFS="---"`修改为用`---`来分隔输出内容。

   ```text
   $ awk -F ":" -v OFS="---" '{print $1,$NF}' test
   #Fields---language_name
   #7---英语
   #8---匈牙利语
   #9---法语
   .....
   ```



### awk动作：格式化输出

awk动作包括两个**打印动作**`print`和`printf`

`printf`命令用于格式化输出，它输出不带换行符，参数如下：

- %s:字符串
- %f:浮点格式（也就是我们概念中的float或者double）
- %b:相对应的参数中包含转义字符时，可以使用此替换符进行替换，对应的转义字符会被转义。
- %c:ASCII字符。显示相对应参数的第一个字符
- %d,:%i:十进制整数
- %o:不带正负号的八进制值
- %u:不带正负号的十进制值
- %x:不带正负号的十六进制值，使用a至f表示10至15
- %X:不带正负号的十六进制值，使用A至F表示10至15
- %% 表示"%"本身
- -:减号代表输出的内容进行左对齐

```text
$ awk 'BEGIN{printf "%-25s\t %-25s\t %-25s\t\n", "id1", "id2", "id3"} {printf "%-25s\t%-25s\t%-25s\n",$2,$3,$4}' hzh_test
id1                              id2                             id3
en                              1                               英语
hu                              2                               匈牙利语
fr                              4                               法语
ro                              8                               罗马尼亚语
```



### awk模式pattern

1. BEGIN/END模式

   awk的`BEGIN`和`END`

   - BEGIN模式是处理文本之前需要执行的操作
   - END模式是处理完所有行之后执行的操作

   ```test
   $ awk 'BEGIN{print "处理之前开始执行的操作"} {print $0} END{print "所有文本处理完之 后执行的操作"} hzh_test
   处理之前开始执行的操作
   7       en      1       英语
   8       hu      2       匈牙利语
   9       fr      4       法语
   所有文本处理完之后执行的操作
   ```
   
2. 关系运算模式

   例子1：
   
   ```text
   $ awk 'NR==2,NR==5{print $0}' test
   $ awk 'NR!=2{print $0}' test
   ```
   例子2：将某一列的数值相加
   
   ```text
   $ cat hzh_test |awk '{sum += $1} END{print sum}'
   255
   ```


3. 空模式

   不指定任何模式



## sort

Linux sort命令将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。

语法：

```bash
sort [OPTION]… [FILE]…
```

**参数说明**：

- -b 忽略每行前面开始出的空格字符。
- -c 检查文件是否已经按照顺序排序。
- -d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。
- -f 排序时，将小写字母视为大写字母。
- -i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。
- -m 将几个排序好的文件进行合并。
- -M 将前面3个字母依照月份的缩写进行排序。
- -n 依照数值的大小排序。
- -u 意味着是唯一的(unique)，输出的结果是去完重了的。
- -o<输出文件> 将排序后的结果存入指定的文件。
- -r 以相反的顺序来排序。
- -t<分隔字符> 指定排序时所用的栏位分隔字符。
- +<起始栏位>-<结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。
- --help 显示帮助。
- --version 显示版本信息。
- [-k field1[,field2]] 按指定的列进行排序。



## uniq

Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。

uniq 可检查文本文件中重复出现的行列。**当重复的行并不相邻时，uniq 命令是不起作用的。**

语法：

```bash
uniq [OPTION]… [FILE]…
```

**参数**：

- -c或--count 在每列旁边显示该行重复出现的次数。
- -d或--repeated 仅显示重复出现的行列。
- -f<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。
- -s<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。
- -u或--unique 仅显示出一次的行列。
- -w<字符位置>或--check-chars=<字符位置> 指定要比较的字符。
- --help 显示帮助。
- --version 显示版本信息。
- [输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；
- [输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。



## head

head 命令可用于查看文件的开头部分的内容，有一个常用的参数 **-n** 用于显示行数，默认为 10，即显示 10 行的内容。

**命令格式：**

```bash
head [参数] [文件]  
```

**参数：**

- -q 隐藏文件名
- -v 显示文件名
- -c<数目> 显示的字节数。
- -n<行数> 显示的行数。



## wc

Linux wc命令用于计算字数。

利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则wc指令会从标准输入设备读取数据。

在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：

```bash
wc 文件名

$ wc recommend_redis_conf_file
6  36 864 recommend_redis_conf_file
```

**参数**：

- -c或--bytes或--chars 只显示Bytes数。
- -l或--lines 显示行数。
- -w或--words 只显示字数。
- --help 在线帮助。
- --version 显示版本信息。



wc命令常常配合其他命令来用，如：

1. 查找文件中字符“100”的个数；

   ```bash
   grep "100" 文件名 | wc -l
   ```

2. 查找文件夹里文件的个数：

   ```bash
   ll | wc -l
   ```



## more

Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。

语法如下：

```bash
more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]
```



**参数**：

- -num 一次显示的行数
- -d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声
- -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能
- -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）
- -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容
- -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料
- -s 当遇到有连续两行以上的空白行，就代换为一行的空白行
- -u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）
- +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示
- +num 从第 num 行开始显示
- fileNames 欲显示内容的文档，可为复数个数



## mkdir

```bash
mkdir dirName #在当前目录下创建目录
mkdir -p dirName/subName/src #创建多级目录
```



## tail

tail 命令可用于查看文件的内容，有一个常用的参数 **-f** 常用于查阅正在改变的日志文件。

**tail -f filename** 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。



**命令格式：**

```
tail [参数] [文件]  
```

**参数：**

- -f 循环读取
- -q 不显示处理信息
- -v 显示详细的处理信息
- -c<数目> 显示的字节数
- -n<行数> 显示文件的尾部 n 行内容
- --pid=PID 与-f合用,表示在进程ID,PID死掉之后结束
- -q, --quiet, --silent 从不输出给出文件名的首部
- -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒



## nohup

**nohup** 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。

**nohup** 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 **$HOME/nohup.out** 文件中。



**语法格式:**

```bash
 nohup Command [ Arg … ] [　& ]
```

**参数说明：**

**Command**：要执行的命令。

**Arg**：一些参数，可以指定输出文件。

**&**：让命令在后台执行，终端退出后命令仍旧执行。



**nohup与&的区别：**

```bash
nohup ./start.sh &
nohup ./start.sh &>out &  #第一个&是后台运行它前面的内容，第二个&是运行两个&之间的内容
```

&的意思是在后台运行， 当你在执行 ./start.sh & 的时候， 即使你用ctrl C, 那么start.sh照样运行（因为对SIGINT信号免疫）。 但是要注意， 如果你直接关掉shell后， 那么，start.sh进程同样消失。

nohup的意思是忽略SIGHUP信号， 所以当运行nohup ./start.sh的时候， 关闭shell, 那么start.sh进程还是存在的（对SIGHUP信号免疫）。 但是， 要注意， 如果你直接在shell中用Ctrl C, 那么start.sh进程也是会消失的（因为对SIGINT信号不免疫）

所以nohup结合&使用，让进程真正不受shell中Ctrl C和shell关闭的影响。



## vim设置

拷贝到linux文本文件中的字符串会被再进行一下缩进。

解决办法：
1，在拷贝前输入:set paste (这样的话，vim就不会启动自动缩进，而只是纯拷贝粘贴）
2，拷贝完成之后，输入:set nopaste (关闭paste)