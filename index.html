<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>胡椒粉的秋天</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="胡椒粉的秋天">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="胡椒粉的秋天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="pepper">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="胡椒粉的秋天" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">胡椒粉的秋天</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-学习计划" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="深度学习基础知识学习"><a href="#深度学习基础知识学习" class="headerlink" title="深度学习基础知识学习"></a>深度学习基础知识学习</h1><p><a target="_blank" rel="noopener" href="https://zh-v2.d2l.ai/chapter_introduction/index.html">https://zh-v2.d2l.ai/chapter_introduction/index.html</a></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 1.引言，2.预备知识：数据操作、数据预处理、线性代数（3.14）</li>
<li><input checked="" disabled="" type="checkbox"> 2.预备知识：微积分、自动微分、概率等（3.15）</li>
<li><input checked="" disabled="" type="checkbox"> 3.线性神经网络：线性回归知识，3.1、3.2、3.3（3.16）</li>
<li><input checked="" disabled="" type="checkbox"> 3.线性神经网络：softmax回归等，3.4、3.5、3.6（3.17）</li>
</ul>
<p>耿直哥</p>
<h1 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h1><ul>
<li><p><input checked="" disabled="" type="checkbox"> 
…..</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
视频P10 GORM事务介绍和使用</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
视频P11 GROM自定义数据类型</p>
</li>
</ul>
<h1 id="es"><a href="#es" class="headerlink" title="es"></a>es</h1><ul>
<li><input checked="" disabled="" type="checkbox"> es，思维导图</li>
</ul>
<h1 id="gin-vue-admin源码研读"><a href="#gin-vue-admin源码研读" class="headerlink" title="gin-vue-admin源码研读"></a>gin-vue-admin源码研读</h1><ul>
<li><input disabled="" type="checkbox"> systemRouter.InitApiRouter(PrivateGroup, PublicGroup)    &#x2F;&#x2F; 注册功能api路由，8个接口</li>
<li><input checked="" disabled="" type="checkbox"> systemRouter.InitJwtRouter(PrivateGroup)                 &#x2F;&#x2F; jwt相关路由，1个接口</li>
<li><input checked="" disabled="" type="checkbox"> systemRouter.InitUserRouter(PrivateGroup)                &#x2F;&#x2F; 注册用户路由</li>
<li><input disabled="" type="checkbox"> systemRouter.InitMenuRouter(PrivateGroup)                &#x2F;&#x2F; 注册menu路由</li>
<li><input disabled="" type="checkbox"> systemRouter.InitSystemRouter(PrivateGroup)              &#x2F;&#x2F; system相关路由</li>
<li><input checked="" disabled="" type="checkbox"> systemRouter.InitCasbinRouter(PrivateGroup)              &#x2F;&#x2F; 权限相关路由，1个接口</li>
<li><input disabled="" type="checkbox"> systemRouter.InitAutoCodeRouter(PrivateGroup)            &#x2F;&#x2F; 创建自动化代码</li>
<li><input checked="" disabled="" type="checkbox"> systemRouter.InitAuthorityRouter(PrivateGroup)           &#x2F;&#x2F; 注册角色路由，6个接口</li>
<li><input disabled="" type="checkbox"> systemRouter.InitSysDictionaryRouter(PrivateGroup)       &#x2F;&#x2F; 字典管理</li>
<li><input disabled="" type="checkbox"> systemRouter.InitAutoCodeHistoryRouter(PrivateGroup)     &#x2F;&#x2F; 自动化代码历史</li>
<li><input disabled="" type="checkbox"> systemRouter.InitSysOperationRecordRouter(PrivateGroup)  &#x2F;&#x2F; 操作记录</li>
<li><input disabled="" type="checkbox"> systemRouter.InitSysDictionaryDetailRouter(PrivateGroup) &#x2F;&#x2F; 字典详情管理</li>
<li><input disabled="" type="checkbox"> systemRouter.InitAuthorityBtnRouterRouter(PrivateGroup)  &#x2F;&#x2F; 字典详情管理</li>
<li><input disabled="" type="checkbox"> systemRouter.InitChatGptRouter(PrivateGroup)             &#x2F;&#x2F; chatGpt接口</li>
<li><input disabled="" type="checkbox"> exampleRouter.InitCustomerRouter(PrivateGroup)              &#x2F;&#x2F; 客户路由</li>
<li><input disabled="" type="checkbox"> exampleRouter.InitFileUploadAndDownloadRouter(PrivateGroup) &#x2F;&#x2F; 文件上传下载功能路由</li>
</ul>
<h1 id="ginblog"><a href="#ginblog" class="headerlink" title="ginblog"></a>ginblog</h1><ul>
<li><input disabled="" type="checkbox"> 返回状态码封装</li>
<li><input disabled="" type="checkbox"> 完善casbin增删改查</li>
</ul>
<h1 id="博客搭建和GitHub搭建"><a href="#博客搭建和GitHub搭建" class="headerlink" title="博客搭建和GitHub搭建"></a>博客搭建和GitHub搭建</h1><p>github</p>
<p>主页搭建</p>
<p>博客</p>
<p>图片</p>
<h1 id="casbin"><a href="#casbin" class="headerlink" title="casbin"></a>casbin</h1><ul>
<li><input checked="" disabled="" type="checkbox"> Casbin 多租户模型（RABC-dom）正确打开方式</li>
</ul>
<h1 id="无服务"><a href="#无服务" class="headerlink" title="无服务"></a>无服务</h1><ul>
<li><input disabled="" type="checkbox"> 无服务</li>
</ul>
<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><ul>
<li><input disabled="" type="checkbox"> 分布式缓存</li>
</ul>
<h1 id="sd原理研读"><a href="#sd原理研读" class="headerlink" title="sd原理研读"></a>sd原理研读</h1><h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><ul>
<li><p><input disabled="" type="checkbox"> 
软连接</p>
</li>
<li><p><input disabled="" type="checkbox"> 
技术方案</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" data-id="clktuzzeb0004cdoo7mw377np" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/nginx" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/">nginx</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  <strong>Nginx</strong> 是开源的轻量级 Web 服务器、反向代理服务器，以及负载均衡器和 HTTP 缓存器。其特点是高并发，高性能和低内存。<br>        <strong>Nginx</strong> 专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，最大能支持 50000 个并发连接数。 Nginx 还支持热部署，它的使用特别容易，几乎可以做到 7x24 小时不间断运行。 Nginx 的网站用户有：百度、淘宝、京东、腾讯、新浪、网易等。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​		<strong>Nginx</strong> 不仅可以做反向代理，实现负载均衡，还能用做正向代理来进行上网等功能。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="nginx正向代理示意图"></p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>​		客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的IP地址。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="nginx反向代理示意图"></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>​		将原先请求集中到单个服务器上的情况改为增加服务器的数量，然后将请求分发到各个服务器上，将负载分发到不同的服务器，即负载均衡。</p>
<h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p> 	为了加快网站的解析速度，可以把静态页面和动态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="nginx动静分离示意图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/" data-id="clktuzzft002dcdoo5yu956j2" data-title="nginx" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端/Reactor 和 Proactor" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/Reactor%20%E5%92%8C%20Proactor/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E5%90%8E%E7%AB%AF/Reactor%20%E5%92%8C%20Proactor/">Reactor 和 Proactor</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。当一个连接对应一个线程时，线程一般采用「read -&gt; 业务处理 -&gt; send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 <code>read</code> 操作上（ socket 默认情况是阻塞 I&#x2F;O），那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I&#x2F;O 多路复用。</p>
<h2 id="I-O-多路复用技术"><a href="#I-O-多路复用技术" class="headerlink" title="I&#x2F;O 多路复用技术"></a>I&#x2F;O 多路复用技术</h2><p>I&#x2F;O 多路复用技术会用一个系统调用函数来监听我们所有关心的连接，也就说可以在一个监控线程里面监控很多的连接，当其中监控的连接有事件发生时，就返回该事件。我们熟悉的 select&#x2F;poll&#x2F;epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。</p>
<p>select&#x2F;poll&#x2F;epoll 是如何获取网络事件的呢？</p>
<p>在获取事件时，先把我们要关心的连接传给内核，再由内核检测：</p>
<ul>
<li>如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。</li>
<li>如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。</li>
</ul>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>基本是基于 I&#x2F;O 多路复用，用过 I&#x2F;O 多路复用接口写网络程序的同学，肯定知道是面向过程的方式写代码的，这样的开发的效率不高。</p>
<p>于是，大佬们基于面向对象的思想，对 I&#x2F;O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写，这就是<strong>Reactor 模式</strong>。</p>
<p>Reactor这里的反应指的是「<strong>对事件反应</strong>」，也就是<strong>来了一个事件，Reactor就有相对应的反应&#x2F;响应</strong>。</p>
<h3 id="单-Reactor-单进程-线程"><a href="#单-Reactor-单进程-线程" class="headerlink" title="单 Reactor 单进程 &#x2F; 线程"></a>单 Reactor 单进程 &#x2F; 线程</h3><p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B.png" alt="单Reactor单进程、线程"></p>
<p>可以看到进程里有 <strong>Reactor、Acceptor、Handler</strong> 这三个对象：</p>
<ul>
<li>Reactor 对象的作用是监听和分发事件；</li>
<li>Acceptor 对象的作用是获取连接；</li>
<li>Handler 对象的作用是处理业务；</li>
</ul>
<p>对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。</p>
<p>接下来，介绍下「单 Reactor 单进程」这个方案：</p>
<ul>
<li>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li>
<li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li>
<li>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</li>
<li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
</ul>
<p>这种方案存在 2 个缺点：</p>
<ul>
<li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li>
<li>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li>
</ul>
<p>所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p>
<p>Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在<strong>内存</strong>中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</p>
<h3 id="单-Reactor-多线程-多进程"><a href="#单-Reactor-多线程-多进程" class="headerlink" title="单 Reactor 多线程 &#x2F; 多进程"></a>单 Reactor 多线程 &#x2F; 多进程</h3><p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B.jpg" alt="单Reactor多线程、多进程"></p>
<p>详细说一下这个方案：</p>
<ul>
<li>Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li>
<li>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</li>
<li>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</li>
</ul>
<p>上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：</p>
<ul>
<li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据<em>发给子线程里的 Processor 对象进行业务处理</em>；</li>
<li>子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；</li>
</ul>
<p>单 Reator 多线程的方案优势在于<strong>能够充分利用多核 CPU 的能</strong>，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。</p>
<p>另外，「单 Reactor」的模式还有个问题，<strong>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</strong>。</p>
<h3 id="多-Reactor-多进程-线程"><a href="#多-Reactor-多进程-线程" class="headerlink" title="多 Reactor 多进程 &#x2F; 线程"></a>多 Reactor 多进程 &#x2F; 线程</h3><p>要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了第 <strong>多 Reactor 多进程 &#x2F; 线程</strong>的方案。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%A4%9AReactor%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B.png" alt="多Reactor多进程、线程"></p>
<p>方案详细说明如下：</p>
<ul>
<li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept  获取连接，将新的连接分配给某个子线程；</li>
<li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接<em>加入 select 继续进行监听</em>，并创建一个 Handler 用于处理连接的响应事件。</li>
<li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</li>
<li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
</ul>
<p>多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：</p>
<ul>
<li>主线程和子线程分工明确，<strong>主线程只负责接收新连接，子线程负责完成后续的业务处理</strong>。</li>
<li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。</li>
</ul>
<p>大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。</p>
<h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2><p>前面提到的 <strong>Reactor 是非阻塞同步网络模式</strong>，而 <strong>Proactor 是异步网络模式</strong>。</p>
<p>这里复习下阻塞、非阻塞、同步、异步 I&#x2F;O 的概念。</p>
<p>先来看看<strong>阻塞 I&#x2F;O</strong>，当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<code>read</code> 才会返回。</p>
<p>注意，<strong>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</strong>。过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E9%98%BB%E5%A1%9EIO.jpg" alt="阻塞IO"></p>
<p>知道了阻塞 I&#x2F;O ，来看看<strong>非阻塞 I&#x2F;O</strong>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，<code>read</code> 调用才可以获取到结果。过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.jpg" alt="非阻塞IO"></p>
<p>无论 read 和 send 是阻塞 I&#x2F;O，还是非阻塞 I&#x2F;O 都是同步调用。因为在 read 调用时，内核将数据从内核空间拷贝到用户空间的过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</p>
<p>而真正的<strong>异步 I&#x2F;O</strong> 是「内核数据准备好」和「数据从内核态拷贝到用户态」这<strong>两个过程都不用等待</strong>。</p>
<p>当我们发起 <code>aio_read</code> （异步 I&#x2F;O） 之后，就立即返回，内核自动将数据从内核空间拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，<strong>应用程序并不需要主动发起拷贝动作</strong>。过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%BC%82%E6%AD%A5IO.jpg" alt="异步IO"></p>
<p>举个你去饭堂吃饭的例子，你好比应用程序，饭堂好比操作系统。</p>
<p>阻塞 I&#x2F;O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。</p>
<p>非阻塞 I&#x2F;O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。</p>
<p>异步 I&#x2F;O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。</p>
<p>很明显，异步 I&#x2F;O 比同步 I&#x2F;O 性能更好，因为异步 I&#x2F;O 在「内核数据准备好」和「数据从内核空间拷贝到用户空间」这两个过程都不用等待。</p>
<p>Proactor 正是采用了异步 I&#x2F;O 技术，所以被称为异步网络模型。</p>
<p>接下来，一起看看 Proactor 模式的示意图：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/Proactor%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Proactor模式的示意图"></p>
<p>介绍一下 Proactor 模式的工作流程：</p>
<ul>
<li>Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过<br>Asynchronous Operation Processor 注册到内核；</li>
<li>Asynchronous Operation Processor 负责处理注册请求，并处理 I&#x2F;O 操作；</li>
<li>Asynchronous Operation Processor 完成 I&#x2F;O 操作后通知 Proactor；</li>
<li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；</li>
<li>Handler 完成业务处理；</li>
</ul>
<p>可惜的是，在 Linux 下的异步 I&#x2F;O 是不完善的，<br><code>aio</code> 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p>
<p>而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <code>IOCP</code>，是由操作系统级别实现的异步 I&#x2F;O，真正意义上异步 I&#x2F;O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。</p>
<h2 id="Reactor-和-Proactor-的区别"><a href="#Reactor-和-Proactor-的区别" class="headerlink" title="Reactor 和 Proactor 的区别"></a>Reactor 和 Proactor 的区别</h2><p>现在我们再来理解 Reactor 和 Proactor 的区别，就比较清晰了。</p>
<ul>
<li><strong>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件</strong>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。</li>
</ul>
<p>因此，<strong>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</strong>，而 <strong>Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</strong>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I&#x2F;O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E5%90%8E%E7%AB%AF/Reactor%20%E5%92%8C%20Proactor/" data-id="clktuzzfv002gcdoo9aend1aq" data-title="Reactor 和 Proactor" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端/负载均衡" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务或者网络请求）进行平衡，分摊到多个操作单元(服务器或者组件)上进行运行。目的是尽量将网络流量 <em><strong>平均</strong></em> 发送到多个服务器上，以保证整个业务系统的高可用。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A11.jpg" alt="负载均衡1"></p>
<p>如何构建和调度服务集群这事情，又必须对用户一侧保持足够的透明，即使请求背后是由一千台、一万台机器来共同响应的，也绝非用户所关心的事情，用户需记住的只有一个域名地址而已。调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为 <em><strong>负载均衡</strong></em>。</p>
<p>负载均衡主要有以下作用：</p>
<ul>
<li>高并发。通过采取一定的算法策略，将流量尽可能的均匀发送给后端的实例，以此提高集群的并发处理能力。</li>
<li>伸缩性。根据网络流量的大小，增加或者减少后端服务器实例，由负载均衡设备进行控制，这样使得集群具有伸缩性。</li>
<li>高可用。负载均衡器通过算法或者其他性能数据来监控候选实例，当实例负载过高或者异常时，减少其流量请求或者直接跳过该实例，将请求发送个其他可用实例，这使得集群具有高可用的特性。</li>
<li>安全防护。有些负载均衡器提供了安全防护功能。如：黑白名单处理、防火墙等。</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="根据载体类型分类"><a href="#根据载体类型分类" class="headerlink" title="根据载体类型分类"></a>根据载体类型分类</h3><p>从支持负载均衡的载体来看，可以将负载均衡分为两类：</p>
<ul>
<li>硬件负载均衡</li>
<li>软件负载均衡</li>
</ul>
<h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>硬件负载平衡器是一种硬件设备，具有专门的操作系统。硬件负载平衡器位于传入流量和内部服务器之间，本质上充当“流量警察”。当用户访问网站或者使用app某个功能时，它们首先被发送到负载均衡器，然后负载均衡器根据一定的策略，将流量转发到后端不同的服务器。为确保最佳性能，硬件负载均衡器根据自定义规则分配流量，以免后端实例不堪重负。</p>
<p>传统上，硬件负载平衡器和应用服务器部署在本地数据中心，负载平衡器的数量取决于预期的峰值流量。负载均衡器通常成对部署，以防其中一个失败。</p>
<p>目前业界领先的两款硬件负载均衡器：F5和A10</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E7%A1%AC%E4%BB%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="硬件负载均衡"></p>
<p><strong>优点</strong>：</p>
<blockquote>
<p>功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</p>
<p>性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</p>
<p>安全性高：往往具备防火墙，防 DDos 攻击等安全功能。</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>成本昂贵：购买和维护硬件负载均衡的成本都很高(：F5价格在15w~55w不等，A10价格在55w-100w不等)。</p>
<p>扩展性差：当访问量突增时，超过限度不能动态扩容。</p>
</blockquote>
<h4 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h4><p>软件负载均衡指的是在服务器的操作系统上安装负载均衡软件，从此服务器发出的请求经软件负载均衡算法路由到后端集群的某一台机器上。</p>
<p>常见负载均衡软件有：LVS、Nginx、Haproxy。</p>
<p><strong>优点</strong></p>
<blockquote>
<p>扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</p>
<p>成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</p>
</blockquote>
<h3 id="根据OSI网络模型分类"><a href="#根据OSI网络模型分类" class="headerlink" title="根据OSI网络模型分类"></a>根据OSI网络模型分类</h3><p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/OSI%E6%A8%A1%E5%9E%8B.jpg" alt="OSI模型"></p>
<p>从上图可以看出：</p>
<blockquote>
<p>TELNET、HTTP、FTP、NFS、SMTP、DNS等属于第七层应用层的概念。</p>
<p>TCP、UDP、SPX等属于第四层传输层的概念。</p>
<p>IP、IPX等属于第三层网络层的概念。</p>
<p>ATM、FDDI等属于第二层数据链路层的概念。</p>
</blockquote>
<p>根据负载均衡技术实现在OSI七层模型的不同层次，我们给负载均衡分类：</p>
<ul>
<li>七层负载均衡：工作在应用层的负载均衡称</li>
<li>四层负载均衡：工作在传输层的负载均衡称</li>
<li>三层负载均衡：工作在网络层的负载均衡，</li>
<li>二层负载均衡：工作在数据链路层的负载均衡。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1OSI.jpg" alt="负载均衡OSI"></p>
<p><em><strong>其中最常用的是四层和七层负载均衡</strong></em>。</p>
<h4 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h4><blockquote>
<p>所谓四层负载均衡，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
</blockquote>
<p>由于四层负载均衡是作用在传输层，因此，我们就以常见的TCP进行举例。</p>
<p>负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="四层负载均衡"></p>
<p>四层负载均衡主要是基于tcp协议报文，可以做任何基于tcp&#x2F;ip协议的软件的负载均衡，比如Haproxy、LVS等。</p>
<h4 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h4><blockquote>
<p>所谓七层负载均衡，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p>
</blockquote>
<p>应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。</p>
<p>我们仍然以TCP为例。负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。</p>
<blockquote>
<p>七层负载均衡器会与客户端 以及 后端的服务实例分别建立连接</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.jpg" alt="七层负载均衡"></p>
<h4 id="对比-四层和七层"><a href="#对比-四层和七层" class="headerlink" title="对比(四层和七层)"></a>对比(四层和七层)</h4><ul>
<li><p>智能性</p>
</li>
<li><ul>
<li>七层负载均衡由于具备OIS七层的所有功能，所以在处理用户需求上能更加灵活，从理论上讲，七层模型能对用户的所有跟服务端的请求进行修改。例如对文件header添加信息，根据不同的文件类型进行分类转发。</li>
<li>四层模型仅支持基于网络层的需求转发，不能修改用户请求的内容。</li>
</ul>
</li>
<li><p>安全性</p>
</li>
<li><ul>
<li>七层负载均衡由于具有OSI模型的全部功能，能更容易抵御来自网络的攻击</li>
<li>四层模型从原理上讲，会直接将用户的请求转发给后端节点，无法直接抵御网络攻击。</li>
</ul>
</li>
<li><p>复杂度</p>
</li>
<li><ul>
<li>四层模型一般比较简单的架构，容易管理，容易定位问题</li>
<li>七层模型架构比较复杂，通常也需要考虑结合四层模型的混用情况，出现问题定位比较复杂。</li>
</ul>
</li>
<li><p>效率比</p>
</li>
<li><ul>
<li>四层模型基于更底层的设置，通常效率更高，但应用范围有限</li>
<li>七层模型需要更多的资源损耗，在理论上讲比四层模型有更强的功能，现在的实现更多是基于http应用。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E5%90%8E%E7%AB%AF/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" data-id="clktuzzfw002icdoo43dv57oz" data-title="负载均衡" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-后端/项目代码分层结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/">项目代码分层结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="通常的项目总体结构"><a href="#通常的项目总体结构" class="headerlink" title="通常的项目总体结构"></a>通常的项目总体结构</h2><p>以Spring Boot典型项目结构为例，创建出来的项目应该总体分为三大层：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/Spring_Boot%E5%85%B8%E5%9E%8B%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="Spring_Boot典型项目结构"></p>
<ul>
<li><code>项目根目录/src/main/java</code>：放置项目Java源代码</li>
<li><code>项目根目录/src/main/resources</code>：放置项目静态资源和配置文件</li>
<li><code>项目根目录/src/test/java</code>：放置项目测试用例代码</li>
</ul>
<h2 id="项目结构划分总结"><a href="#项目结构划分总结" class="headerlink" title="项目结构划分总结"></a>项目结构划分总结</h2><p>如果从一个用户访问一个网站的情况来看，对应着上面的项目代码结构来分析，可以贯穿整个代码分层：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82.png" alt="后端服务代码分层"></p>
<p>对应代码目录的流转逻辑就是：</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E6%B5%81%E8%BD%AC%E9%80%BB%E8%BE%91.jpg" alt="后端服务代码分层流转逻辑"></p>
<p>各个目录详细介绍：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|_annotation：放置项目自定义注解</span><br><span class="line">|_aspect：放置切面代码</span><br><span class="line">|_config：放置配置类</span><br><span class="line">|_constant：放置常量、枚举等定义</span><br><span class="line">   |__constnt：存放常量定义</span><br><span class="line">   |__enums：存放枚举定义</span><br><span class="line">|_controller：放置控制器代码</span><br><span class="line">|_filter：放置一些过滤、拦截相关的代码</span><br><span class="line">|_mapper：放置数据访问层代码接口</span><br><span class="line">|_model：放置数据模型代码</span><br><span class="line">   |__entity：放置数据库实体对象定义</span><br><span class="line">   |__dto：存放数据传输对象定义</span><br><span class="line">   |__vo：存放显示层对象定义</span><br><span class="line">|_service：放置具体的业务逻辑代码（接口和实现分离）</span><br><span class="line">   |__intf：存放业务逻辑接口定义</span><br><span class="line">   |__impl：存放业务逻辑实际实现</span><br><span class="line">|_utils：放置工具类和辅助代码</span><br></pre></td></tr></table></figure>

<p>然后接下来<code>/src/main/resources</code>目录，里面主要存放静态配置文件和页面静态资源等东西：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|_mapper：存放mybatis的XML映射文件（如果是mybatis项目）</span><br><span class="line">|_static：存放网页静态资源，比如下面的js/css/img</span><br><span class="line">   |__js：</span><br><span class="line">   |__css：</span><br><span class="line">   |__img：</span><br><span class="line">   |__font：</span><br><span class="line">   |__等等</span><br><span class="line">|_template：存放网页模板，比如thymeleaf/freemarker模板等</span><br><span class="line">   |__header</span><br><span class="line">   |__sidebar</span><br><span class="line">   |__bottom</span><br><span class="line">   |__XXX.html等等</span><br><span class="line">|_application.yml       基本配置文件</span><br><span class="line">|_application-dev.yml   开发环境配置文件</span><br><span class="line">|_application-test.yml  测试环境配置文件</span><br><span class="line">|_application-prod.yml  生产环境配置文件</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>DO（Data Object）</code>：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</p>
</li>
<li><p><code>DTO（Data Transfer Object）</code>：数据传输对象，Service或Manager向外传输的对象。</p>
</li>
<li><p><code>BO（Business Object）</code>：业务对象。由Service层输出的封装业务逻辑的对象。</p>
</li>
<li><p><code>AO（Application Object）</code>：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</p>
</li>
<li><p><code>VO（View Object）</code>：显示层对象，通常是Web向模板渲染引擎层传输的对象。</p>
</li>
<li><p><code>Query</code>：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</p>
</li>
</ul>
<h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><p>1、<code>Contorller</code>层参数传递建议不要使用<code>HashMap</code>，建议使用数据模型定义</p>
<p>2、<code>Controller</code>层里可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到<code>Service</code>层代码中去做</p>
<p>3、<code>Service</code>层做实际业务逻辑，可以按照功能模块做好定义和区分，相互可以调用</p>
<p>4、功能模块<code>Service</code>之间引用时，建议不要渗透到<code>DAO</code>层（或者<code>mapper</code>层），基于<code>Service</code>层进行调用和复用比较合理</p>
<p>5、业务逻辑层<code>Service</code>和数据库<code>DAO</code>层的操作对象不要混用。<code>Controller</code>层的数据对象不要直接渗透到<code>DAO</code>层（或者<code>mapper</code>层）；同理数据表实体对象<code>Entity</code>也不要直接传到<code>Controller</code>层进行输出或展示。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/" data-id="clktuzzfy002mcdoo7igd6do5" data-title="项目代码分层结构" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构/二叉树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：</p>
<p>节点的高度&#x3D;节点到叶子节点的<strong>最长路径</strong>（边数）</p>
<p>节点的深度&#x3D;根节点到这个节点所经历的<strong>边的个数</strong></p>
<p>节点的层数&#x3D;节点的深度+1</p>
<p>树的高度&#x3D;根节点的高度</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%95%B0.png" alt="二叉树的高度深度层数"></p>
<p>其中有两种特殊的二叉树：</p>
<p>二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做<strong>满二叉树</strong>。</p>
<p>二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做<strong>完全二叉树</strong>。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树</strong>？这就要从二叉树存储方面说起了。</p>
<p>想要存储一棵二叉树，我们有两种方法，</p>
<ul>
<li>一种是基于指针或者引用的二叉链式存储法。</li>
<li>一种是基于数组的顺序存储法。</li>
</ul>
<h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>从图中可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="二叉树的链式存储"></p>
<h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>我们把根节点存储在下标 i &#x3D; 1 的位置，那左子节点存储在下标 2 * i &#x3D; 2 的位置，右子节点存储在 2 * i + 1 &#x3D; 3 的位置。以此类推，B 节点的左子节点存储在 2 * i &#x3D; 2 * 2 &#x3D; 4 的位置，右子节点存储在 2 * i + 1 &#x3D; 2 * 2 + 1 &#x3D; 5 的位置。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="完全二叉树的顺序存储"></p>
<p>我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</p>
<p>不过，我刚刚举的例子是一棵完全二叉树，<strong>所以仅仅“浪费”了一个下标为 0 的存储位置</strong>。如果是非完全二叉树，其实会浪费比较多的数组存储空间。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E9%9D%9E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="非完全二叉树的顺序存储"></p>
<p>所以，<strong>如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式</strong>。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p>
<p>当我们讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>如何将所有节点都遍历打印出来呢？经典的方法有三种，前序遍历、中序遍历和后序遍历。</p>
<blockquote>
<p>前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p>
</blockquote>
<ul>
<li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。（中左右）</li>
<li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。（左中右）</li>
<li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。（左右中）</li>
</ul>
<h3 id="深度优先遍历（递归）"><a href="#深度优先遍历（递归）" class="headerlink" title="深度优先遍历（递归）"></a>深度优先遍历（递归）</h3><p>Leetcode: 144. 二叉树的前序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> <span class="comment">//1、递归需要的参数和返回值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == cur) <span class="comment">//2、递归终止条件，当前节点等于空，直接返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、递归中的逻辑，前序遍历（中左右）</span></span><br><span class="line">    res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, res);</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="广度优先遍历（层序遍历）"><a href="#广度优先遍历（层序遍历）" class="headerlink" title="广度优先遍历（层序遍历）"></a>广度优先遍历（层序遍历）</h3><p>Leetcode：107.二叉树的层序遍历 II</p>
<p>给定一个二叉树，返回其节点值<strong>自底向上的层序遍历</strong>。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<p>  3</p>
<p>  &#x2F; \</p>
<p> 9 20</p>
<p>  &#x2F; \</p>
<p>  15  7</p>
<p>返回其自底向上的层序遍历为：</p>
<p>[</p>
<p> [15,7],</p>
<p> [9,20],</p>
<p> [3]</p>
<p>]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//层序遍历方式就是图论中的广度优先遍历</span></span><br><span class="line">    <span class="comment">//用辅助队列实现，先进先出，符合一层一层遍历的逻辑</span></span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != root)</span><br><span class="line">    &#123;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())   <span class="comment">//循环一次，处理树的一层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始对处理队列里的值，先取出当前队列中节点的val，然后队列弹出该值，然后再获取节点的左右节点，存入队列中</span></span><br><span class="line">        <span class="type">int</span> iSize = que.<span class="built_in">size</span>();   <span class="comment">//循环一次，处理一个节点</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; iSize; ++i)<span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            que.<span class="built_in">pop</span>();  <span class="comment">//弹出在front位置的值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left != <span class="literal">NULL</span>)   que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right != <span class="literal">NULL</span>)   que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());    <span class="comment">//最后进行翻转</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是为了实现快速查找而生的。不过，<strong>它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据</strong>。二叉查找树要求，<strong>在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</strong>。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>Leetcode：700. 二叉搜索树中的搜索</p>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<p>给定二叉搜索树:</p>
<p>​    4</p>
<p>​    &#x2F; \</p>
<p>   2  7</p>
<p>   &#x2F; \</p>
<p>  1  3</p>
<p>和值: 2</p>
<p>你应该返回如下子树:</p>
<p>   2  </p>
<p>   &#x2F; \ </p>
<p>  1  3</p>
<p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p>
<p>思路分析：因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p>
<p>如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。</p>
<p>这里可能会疑惑，在递归遍历的时候，什么时候直接return 递归函数的返回值，什么时候不用加这个 return呢。如果要搜索一条边，递归函数就要加返回值，这里也是一样的道理。</p>
<p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val)    <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val == val)   <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。</p>
<p>有一个重要的特性，就是<strong>中序遍历</strong>二叉查找树，可以输出<strong>有序的数据序列</strong>，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。</p>
<h3 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h3><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="各式各样的二叉查找树"></p>
<p>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<p>显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是一种特殊的二叉查找树，<strong>平衡二叉查找树</strong>。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。</p>
<h3 id="二叉查找树与哈希表区别"><a href="#二叉查找树与哈希表区别" class="headerlink" title="二叉查找树与哈希表区别"></a>二叉查找树与哈希表区别</h3><p>相对散列表，二叉查找树好像并没有什么优势，那我们<strong>为什么还要用二叉查找树</strong>呢？我认为有下面几个原因：</p>
<p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p>
<p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p>
<p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p>
<p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p>
<h2 id="平衡二叉查找树（Balanced-BST）"><a href="#平衡二叉查找树（Balanced-BST）" class="headerlink" title="平衡二叉查找树（Balanced BST）"></a>平衡二叉查找树（Balanced BST）</h2><p>基于BST存在的问题，平衡二叉查找树（Balanced BST）产生了。平衡树的插入和删除的时候，会通过旋转操作将高度保持在LogN。其中两款具有代表性的平衡树分别为<strong>AVL树</strong>和<strong>红黑树</strong>。</p>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>1.它的左子树和右子树都是平衡二叉树；<br>2.且它的左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1；</p>
<p>简单的说，就是为了保证平衡，当前节点的左子树、右子树的高度差不超过1！当树的左、右子树高度超过差超过1时，核心就是通过左旋转、右旋转实现树再次高度平衡。</p>
<h3 id="红黑树Red-Black-Tree（RBTree）"><a href="#红黑树Red-Black-Tree（RBTree）" class="headerlink" title="红黑树Red-Black Tree（RBTree）"></a>红黑树Red-Black Tree（RBTree）</h3><p>1.任何一个节点都有颜色，红色或黑色<br>2.根节点是黑色的<br>3.父子节点之间不能出现两个连续的红节点<br>4.任何一个根节点，遍历到他的子孙节点，所经过的黑色节点数必须相同<br>5.空节点被认为是黑色的</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<p>它的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; parent;</span><br><span class="line">    <span class="keyword">public</span> boolean isRed;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; left;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;T&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为以上规则的限制，保证了红黑树的自平衡。红黑树从根到叶子节点的最长路径不会超过最短路径的2倍。</p>
<p>作为二叉查找树中面众多的实现之一，红黑树通过引入颜色的概念，通过颜色约束的使用，包括<strong>变色</strong>和<strong>旋转</strong>，来保持树的高度平衡。即使在最坏的情况下，操作的时间复杂度也为O(LogN)，原因是整个红黑树的高度保持是LogN(因为旋转修复)，N 为树中的顶点数目。。	</p>
<h3 id="红黑树RBT与平衡二叉树AVL比较"><a href="#红黑树RBT与平衡二叉树AVL比较" class="headerlink" title="红黑树RBT与平衡二叉树AVL比较"></a>红黑树RBT与平衡二叉树AVL比较</h3><p>AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。所以<strong>当你的应用涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树</strong>；当然，如果你的应用中涉<strong>及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现</strong>。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树是一种多路自平衡的搜索树（B树是<strong>一颗多路平衡查找树</strong>），它类似普通的平衡二叉树，不同的一点是B-树允许每个节点有更多的子节点。</p>
<ul>
<li><p><strong>规则：</strong></p>
<p>（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
<p>（2）子节点数：非叶节点的子节点数&gt;1，且&lt;&#x3D;M ，且M&gt;&#x3D;2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M&#x3D;M路,当M&#x3D;2则是2叉树,M&#x3D;3则是3叉）；</p>
<p>（3）关键字数：枝节点的关键字数量大于等于ceil(m&#x2F;2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p>
<p>（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;</p>
</li>
</ul>
<p>传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等，这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了，它们由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。所以，我们为了减少磁盘ＩＯ的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。因为当数据量非常大时，内存不够用，这时使用B-树作为索引，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。</p>
<p>&#x3D;&#x3D;<strong>B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</strong>&#x3D;&#x3D;</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/B-%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="B-树结构图"></p>
<ul>
<li><p><strong>B树的查询流程：</strong></p>
<p>如上图我要从上图中找到E字母，查找流程如下</p>
<p>（1）获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</p>
<p>（2）拿到关键字D和G，由于D&lt;E&lt;G ，所以直接找到D和G中间的节点；</p>
<p>（3）拿到E和F，因为E&#x3D;E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p>
</li>
</ul>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><ul>
<li><p><strong>规则：</strong></p>
<p>（1）B+跟B树不同B+树的<strong>非叶子</strong>节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个<strong>非叶子</strong>节点所能保存的关键字大大增加；</p>
<p>（2）B+树<strong>叶子</strong>节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</p>
<p>（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p>（4）非叶子节点的子节点数&#x3D;关键字数;</p>
</li>
</ul>
<p>B树和B+树，本质上都是一样的，只是B+树所有的跟节点和枝节点上只保存关键字索引和其子节点指针，<strong>所有的数据信息都被保存到了叶子节点</strong>，这样每个枝节点可以存储更多的数据，从而<strong>降低树的层级高度</strong>，并且所有的叶子节像是一个链表一样，<strong>指向右边的叶子节点</strong>，从而可以<strong>有效加快检索效率</strong>，如果需要遍历所有的数据，只需要遍历叶子节点链式结构即可，方便且高效。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%E5%B8%A6%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84B+%E6%A0%91.png" alt="带顺序访问的B+树"></p>
<p>B+树由于只有叶子节点保存了data，所以必须经历O(logn)复杂度才能找到数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="clktuzzfz002ocdoo18eod38s" data-title="二叉树" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构/位图BitMap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E5%9B%BEBitMap/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E5%9B%BEBitMap/">位图BitMap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>给40亿个不重复的无符号整数，没排过序。给一个无符号整数，如何快速判断一个数是否在这40亿个数中。</p>
<h2 id="位图BitMap"><a href="#位图BitMap" class="headerlink" title="位图BitMap"></a>位图BitMap</h2><p>位图BitMap：位图是一个<strong>数组</strong>的<strong>每一个数据</strong>的<strong>每一个二进制位</strong>表示一个数据，0表示数据不存在，1表示数据存在。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/BitMap%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="BitMap示意图"></p>
<p>图中，第一行数值表示一个uint类型（4个字节），136存放在第四个uint类型里，并在该uint类型的第25bit位置上。</p>
<p>BitMap实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitMap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BitMap</span>(<span class="type">size_t</span> range)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//此时多开辟一个空间</span></span><br><span class="line">        _bits.<span class="built_in">resize</span>(range &gt;&gt; <span class="number">5</span> + <span class="number">1</span>);	<span class="comment">//range &gt;&gt; 5等价于range / 32</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = x / <span class="number">32</span>;<span class="comment">//确定哪个数据（区间）</span></span><br><span class="line">        <span class="type">int</span> temp = x % <span class="number">32</span>;<span class="comment">//确定哪个Bit位		x&amp;7==x%8.该Byte里第几个 </span></span><br><span class="line">        _bits[index] |= (<span class="number">1</span> &lt;&lt; temp);<span class="comment">//位操作即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = x / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> temp = x % <span class="number">32</span>;</span><br><span class="line">        _bits[index] &amp;= ~(<span class="number">1</span> &lt;&lt; temp);<span class="comment">//取反</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Get</span><span class="params">(<span class="type">size_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = x / <span class="number">32</span>;</span><br><span class="line">        <span class="type">int</span> temp = x % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">if</span> (_bits[index]&amp;(<span class="number">1</span>&lt;&lt;temp))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; _bits;	<span class="comment">//有(n/32)个int，每个int有32个bit位置</span></span><br><span class="line">    <span class="comment">//此外也可以使用char* _bits; int gsize; 此时有(n/8)个char，每个char有8个bit位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设我们需要查找1000范围内的数值，则需要<code>BitMap bm(1000);</code>内部的<code>_bits</code>生成了32个int就可以保存0~1000的值。（一个int，有32个bit，32个int就有1024个bit，每个bit就可以保存一个数值）</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>40亿QQ号码，用位图中的1个bit存储一个QQ号码，那么8个bit等于1个字节，40亿&#x2F;8&#x2F;1024&#x2F;1024&#x3D;476M，只需要不到512MB就可以存储完40亿QQ号码。</p>
<p>使用上面的BitMap类，使用Set方法，把40亿个QQ号码存到位图中，然后只需要调用Get方法，判断该bit位置的值是否为1就可以知道QQ号码是否存在。</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="问题一：用BitMap进行排序"><a href="#问题一：用BitMap进行排序" class="headerlink" title="问题一：用BitMap进行排序"></a>问题一：用BitMap进行排序</h3><p>文件中有40亿个互不相同的QQ号码，请设计算法对QQ号码进行排序，内存限制1G. </p>
<p>直接用bitmap存40亿个QQ号码，然后从小到大遍历正整数，当bitmapFlag的值为1时，就输出该值，输出后的正整数序列就是排序后的结果。</p>
<h3 id="问题二：用BitMap求Top-K问题"><a href="#问题二：用BitMap求Top-K问题" class="headerlink" title="问题二：用BitMap求Top-K问题"></a>问题二：用BitMap求Top-K问题</h3><p>文件中有40亿个互不相同的QQ号码，求这些QQ号码的top-K，内存限制1G. </p>
<p>除了小顶堆或者文件切割方法外，可以直接用bitmap排序，解决top-K问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BD%8D%E5%9B%BEBitMap/" data-id="clktuzzg1002scdooa9qp6ue8" data-title="位图BitMap" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BitMap/" rel="tag">BitMap</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构/哈希表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="哈希表的基本概念"><a href="#哈希表的基本概念" class="headerlink" title="哈希表的基本概念"></a>哈希表的基本概念</h2><p>我们把数值转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值（或“Hash 值”“哈希值”）。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表"></p>
<p>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标（哈希值），然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>不同的key值，进过哈希函数的计算，理论上应该得到不同的哈希值（存储位置的下标），但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>我们常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？我先讲一个比较简单的探测方法，线性探测（Linear Probing）。</p>
<p>当我们往散列表中<strong>插入数据</strong>时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，遍历到尾部都没有找到空闲的位置，就会再从表头开始找，直到找到为止。如下图，这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95.png" alt="哈希函数-线性探测法"></p>
<p>此外，在散列表中<strong>查找元素</strong>的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的<u>空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</u></p>
<p>由于查找元素找到空闲位置没找到就会被认为哈希表中无此元素，所以<strong>删除元素</strong>不能直接把要删除的元素设置为空。将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%93%88%E5%B8%8C%E8%A1%A8-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0.png" alt="哈希表-线性探测法-删除元素"></p>
<p>线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测（Quadratic probing）</strong>和<strong>双重散列（Double hashing）</strong>。</p>
<p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p>
<p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
<h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E5%93%88%E5%B8%8C%E8%A1%A8-%E9%93%BE%E8%A1%A8%E6%B3%95.png" alt="哈希表-链表法"></p>
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k&#x3D;n&#x2F;m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
<p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为<strong>其他高效的动态数据结构，比如跳表、红黑树</strong>。这样，<u>即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)</u>。这样也就有效避免了前面讲到的散列碰撞攻击。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/" data-id="clktuzzg2002ucdoo770bb6xu" data-title="哈希表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-深度学习/词义理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%8D%E4%B9%89%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据集通常可以分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。</p>
<p>过拟合（overfitting）：当一个模型在训练集上表现良好，但在测试集时测试时候表现并不好。</p>
<p>词义理解</p>
<p>1、<strong>词向量的维度</strong>（通常为512）</p>
<p>2、卷积（convolution：本质不变的变换）：<strong>卷积的本质是滤波（特征提取），操作是加权平均、乘加运算，其目的是提取有用信息。</strong></p>
<blockquote>
<p>延伸阅读：在通常的深度学习卷积层，有填充（Padding）、步长（Stride）的概念，这样做的好处是对防止图像边缘信息丢失、图像尺寸的控制更好，这使得操作与二维卷积的经典公式差别更大，但是convolution的本质含义并没有改变。</p>
</blockquote>
<p>信号处理领域：卷积就是对信号进行滤波</p>
<p>图像领域：卷积就是对图像特征的提取</p>
<p>3、梯度</p>
<p>梯度是一个矢量，在其方向上的方向导数最大，也就是函数在该点处沿着梯度的方向变化最快，变化率最大。</p>
<p>那么在机器学习中逐步逼近、迭代求解最优化时，经常会使用到梯度，沿着梯度向量的方向是函数增加的最快，更容易找到函数的最大值，反过来，沿着梯度向量相反的地方，梯度减少的最快，更容易找到最小值。</p>
<p>PyTorch的自动微分引擎只能计算标量输出的梯度。换句话说，如果你试图在一个非标量值（如一个张量）上调用<code>.backward()</code>，就会出现这个错误。这是因为梯度是一个向量，不能自动计算一个向量对一个向量的导数，需要将一个向量转换为一个标量值，比如将一个向量的所有元素相加，得到一个标量，然后再计算其梯度。因此，如果你想对一个张量求导，你需要将它的所有元素进行加权平均，得到一个标量输出，然后再计算它的梯度。</p>
<p>∂loss&#x2F;∂b 和 ∂loss&#x2F;∂w 就是损失函数关于偏置 b 和权重 w 的梯度，通常简称为梯度。梯度是一个向量，它的每个元素对应一个参数，表示在该参数上增加一个微小的变化会对损失函数产生多大的影响。</p>
<p>反向传播：</p>
<p>在反向传播过程中，我们需要计算损失函数对每个参数的梯度，这需要从损失函数出发，将梯度信息沿着网络层反向传递。具体来说，我们首先计算输出的损失函数关于输出层的输出的梯度，然后将梯度沿着网络层反向传递，一直到输入层。在反向传播的过程中，每个神经元会接收来自上一层神经元的梯度，然后根据链式法则计算本层神经元的梯度，并将梯度传递给下一层。</p>
<p>计算图：</p>
<p>计算图（Computation Graph）是机器学习中一种重要的概念，用于描述计算过程中各个变量之间的依赖关系。</p>
<p>在计算图中，每个节点表示一个变量或操作，每条边表示变量之间的依赖关系。计算图中的计算过程通常分为两个阶段：前向传播和反向传播。在前向传播阶段，从输入节点开始，按照依赖关系依次计算每个节点的值，最终得到输出节点的值；在反向传播阶段，从输出节点开始，按照依赖关系依次计算每个节点的梯度，最终得到输入节点的梯度。这种按照依赖关系计算的过程称为自动微分（Automatic Differentiation），也称为反向传播算法（Backpropagation）。</p>
<p>PyTorch 中的张量（Tensor）和模型（Module）都可以构建计算图，每个张量和模型都是计算图中的一个节点。在进行前向传播和反向传播时，PyTorch 会自动构建计算图，并根据计算图计算每个节点的值和梯度。</p>
<p>计算图是机器学习中重要的概念之一，它可以帮助我们更好地理解模型的计算过程和梯度的计算过程，从而更好地设计和优化机器学习模型。</p>
<p>导数是微积分学中重要的基础概念，<strong>简单来讲就是指一个函数在某一点处的变化率。</strong></p>
<ul>
<li><strong>导数 表示 变化率</strong></li>
<li><strong>微分 表示 变化量</strong></li>
</ul>
<p><strong>偏导数指的是多元函数在某一点处关于某一变量的导数。</strong></p>
<p><strong>梯度其实就是一个包含所有偏导数的向量</strong>，表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在该点处沿着该方向变化最快，变化率最大。</p>
<p>激活函数是非线性的，它的本质是引入非线性</p>
<p>交叉熵</p>
<p>图像的项目跟embedding有什么关系，为什么不需要转换成embedding进行处理</p>
<p>embedding是张量吗</p>
<p>什么是解决非线性问题：例如图像分类、自然语言处理等。</p>
<p>线性问题</p>
<p>损失函数（loss function），或“目标函数”、“代价函数”</p>
<p>如果使用的是回归问题的均方误差（MSE）作为目标函数，就可以根据均方误差的大小来调整模型的参数。</p>
<p>怎么定义目标函数，代码怎么对应</p>
<p>上采样是指将特征图的分辨率还原到原始图片的分辨率大小</p>
<p>安装anaconda更改镜像源</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>







<p>向量还可以被用来表示向量空间模型的线性变换。在机器学习中，可以通过矩阵乘法来对向量进行线性变换。这种变换可以用来调整向量的方向和大小，从而使模型能够更好地学习数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.block8 = nn.Sequential(*block8) #星号代表什么</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netG.train()  # 开启训练模式，为什么线性模型不需要训练模式</span><br></pre></td></tr></table></figure>

<p>torchvision.transforms.Compose：<em>这个类的主要作用是串联多个图片变换的操作。</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 2x3x4 的张量</span></span><br><span class="line">A = torch.tensor([[[<span class="number">83</span>, <span class="number">76</span>, <span class="number">89</span>, <span class="number">91</span>], [<span class="number">78</span>, <span class="number">84</span>, <span class="number">79</span>, <span class="number">85</span>], [<span class="number">89</span>, <span class="number">92</span>, <span class="number">87</span>, <span class="number">94</span>]],</span><br><span class="line">                  [[<span class="number">91</span>, <span class="number">87</span>, <span class="number">92</span>, <span class="number">89</span>], [<span class="number">85</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">90</span>], [<span class="number">90</span>, <span class="number">93</span>, <span class="number">91</span>, <span class="number">94</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第二个学生的数学成绩的所有考试成绩</span></span><br><span class="line">math_scores = A[<span class="number">1</span>][<span class="number">0</span>][:]  <span class="comment"># tensor([85, 88, 87, 90])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有学生在第二次考试中的所有成绩</span></span><br><span class="line">second_exam_scores = A[:, <span class="number">1</span>, <span class="number">1</span>]  <span class="comment"># tensor([84, 88])</span></span><br></pre></td></tr></table></figure>

<p>这个 2x3x4 的张量中的每个数字分别代表着学生成绩的不同信息：</p>
<ul>
<li>第一个维度（axis 0）表示学生的序号，包含两个学生。</li>
<li>第二个维度（axis 1）表示科目，包含三个科目：数学、英语和体育。</li>
<li>第三个维度（axis 2）表示考试次数，每个学科包含四次考试成绩。</li>
</ul>
<p>这里，我们使用 PyTorch 的函数 <code>torch.tensor()</code> 来创建了一个 2x3x4 的张量 A，它保存了学生的成绩信息。然后，我们通过索引来获取了该张量中的数据。</p>
<p><code>A[1][0][:]</code> 表示获取第二个学生的数学成绩的所有考试成绩，我们在第一个维度上使用了索引 1，表示获取第二个学生的信息；在第二个维度上使用了索引 0，表示获取数学这一科目的信息；在第三个维度上使用了<code>:</code>，表示获取该学生在所有数学考试中的成绩。最终返回了一个包含四个元素的一维张量（tensor）。</p>
<p><code>A[:, 1, 1]</code> 表示获取所有学生在第二次考试中的所有成绩，我们在第一个维度上使用了<code>:</code>，表示获取所有学生的信息；在第二个维度上使用了索引 1，表示获取英语这一科目的信息；在第三个维度上使用了索引 1，表示获取所有学生在第二次考试中的成绩。最终返回了一个包含两个元素的一维张量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AF%8D%E4%B9%89%E7%90%86%E8%A7%A3/" data-id="clktuzzg4002ycdoodbycemba" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法/位操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E7%AE%97%E6%B3%95/%E4%BD%8D%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E7%AE%97%E6%B3%95/%E4%BD%8D%E6%93%8D%E4%BD%9C/">位操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一些基本的位操作</p>
<p>判断整数的奇偶性：if((n &amp; 1) &#x3D;&#x3D; 0)</p>
<p>乘以2操作：n &lt;&lt; 1</p>
<p>向下整除n &#x2F;&#x2F; 2：n &gt;&gt; 1</p>
<h2 id="实现某些库函数"><a href="#实现某些库函数" class="headerlink" title="实现某些库函数"></a>实现某些库函数</h2><h3 id="乘法的实现"><a href="#乘法的实现" class="headerlink" title="乘法的实现"></a>乘法的实现</h3><p>如何不用任何运算符计算两个正整数的乘积？</p>
<p>思路分析：</p>
<ul>
<li><p>先判断a和b的正负，保存正负号，如果a或者b是负数，要把a和b转换成正数；</p>
</li>
<li><p>假设两个数a * b，相当于把a自加(b-1)次，而a的自加，可以通过位运算来实现，即a+a相当于a * 2，即把a向左移一位，如此只需做(b-1)的左移即可；a左移一位，增大一倍，b就右移一位，减少一半；此外当b为奇数时，保存a的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiplication</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign = -sign;</span><br><span class="line">        b = -b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sign = -sign;</span><br><span class="line">        a = -a;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 以12*7为例子</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 12 * 7</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span> == <span class="number">0</span>)	<span class="comment">// b为奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = ret + a; <span class="comment">// ret先加上一个a,ret = 0 + 12</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 经过上一步，12 * 7 变为 12 * 6</span></span><br><span class="line">        <span class="comment">// 再把12*6-&gt;12*2*3-&gt;24*3-&gt;24*2</span></span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;	<span class="comment">// 相当于a*2</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;	<span class="comment">// 相当于b减少一半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret*sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E7%AE%97%E6%B3%95/%E4%BD%8D%E6%93%8D%E4%BD%9C/" data-id="clktuzzg50030cdoodlm599bi" data-title="位操作" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GO/">GO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E9%9B%85%E5%86%99%E4%BD%9C/">优雅写作</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E9%9B%85%E5%86%99%E4%BD%9C/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">图床搭建</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">全文搜索引擎</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitMap/" rel="tag">BitMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/" rel="tag">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/" rel="tag">vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%A8%E5%85%B5/" rel="tag">哨兵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag">高可用</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BitMap/" style="font-size: 10px;">BitMap</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/C-11/" style="font-size: 10px;">C++11</a> <a href="/tags/MySql/" style="font-size: 13.33px;">MySql</a> <a href="/tags/Redis/" style="font-size: 20px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/go/" style="font-size: 16.67px;">go</a> <a href="/tags/k8s/" style="font-size: 13.33px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/%E5%93%A8%E5%85%B5/" style="font-size: 10px;">哨兵</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 16.67px;">算法</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 10px;">负载均衡</a> <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" style="font-size: 13.33px;">高可用</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/02/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/">nginx</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/Reactor%20%E5%92%8C%20Proactor/">Reactor 和 Proactor</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/">项目代码分层结构</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 pepper<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>