<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>胡椒粉的秋天</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="胡椒粉的秋天">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="胡椒粉的秋天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="pepper">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="胡椒粉的秋天" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">胡椒粉的秋天</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Git/Git命令基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/Git/Git%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/Git/Git%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/">Git命令基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>首先创建一个文件夹，然后cd到该文件夹下，输入以下命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>当前目录下会多了一个.git的目录，让git帮助我们管理当前文件夹。</p>
<h2 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h2><p>远程仓库的默认名称是<code>origin</code><br>远程仓库主分支<code>origin master</code><br>本地仓库主分支<code>master</code></p>
<h3 id="git区域"><a href="#git区域" class="headerlink" title="git区域"></a>git区域</h3><ul>
<li>工作区：就是你在电脑里能看到的目录</li>
<li>暂存区：一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们有时也把暂存区叫作索引（index）</li>
<li>版本库：工作区有一个隐藏目录.git</li>
</ul>
<p>管理文件（红变绿）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名	（*代表全部文件）</span><br></pre></td></tr></table></figure>

<p>提交一条信息命令，<strong>生成一个版本</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>git add把文件添加进去，实际上就是把<strong>工作区</strong>文件修改添加到<strong>暂存区</strong>；<br>git commit是一次性提交暂存区的全部更改，实际上就是把<strong>暂存区</strong>的所有内容提交到<strong>本地的当前分支（master）</strong>。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/git%20img4.png" alt="git img4"></p>
<p>查看版本记录：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>






<h3 id="版本回退与撤销修改"><a href="#版本回退与撤销修改" class="headerlink" title="版本回退与撤销修改"></a>版本回退与撤销修改</h3><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。（只能看到当前版本之前的历史版本）<br>要重返未来，用<code>git reflog</code>查看历史命令，以便确定要回到未来的哪个版本。（可以看到全部版本）</p>
<h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><p>当改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h4><p>当工作区某个文件的内容添加到了暂存区时（add），想撤销暂存，用命令<code>git reset HEAD &lt;file&gt;</code>或者<code>git restore --staged 文件名</code>。</p>
<h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h4><p>已经提交了不合适的修改到版本库时，想要撤销本次提交，并且回到之前任一个版本，使用命令<code>git reset --hard commit_id</code>，这时，如果想推送到远程库，必须使用<code>git push -f </code>强制推送。</p>
<p>reset参数：</p>
<ul>
<li>–soft：只更新版本库内容</li>
<li>–mixed：更新版本库、暂存区内容</li>
<li>–hard：更新版本库、暂存区内容</li>
</ul>
<p><u>注：<code>git checkout -- file</code>也可以用来恢复工作区删除了的文件，前提是该文件已经提交到版本库。</u></p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>方法一：将已提交到暂存区的某个文件从工作区中删除，执行<code>rm -rf a.txt  # 删除文件</code>，再执行<code>git add .</code>完成删除。</p>
<p>方法二：使用 <code>git rm a.txt</code> 命令删除已跟踪的文件。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/git%E5%88%86%E6%94%AF.png" alt="git分支"></p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建分支: git branch 分支名</span><br><span class="line">切换分支: git checkout 分支名  或者 git switch 分支名</span><br><span class="line">查看所有分支: git branch -a</span><br><span class="line">分支合并: git merge 要合并的分支名 (把分支合并到当前分支)</span><br><span class="line">（合并分支有冲突，则手动把冲突解决，再提交）</span><br></pre></td></tr></table></figure>

<p>注：创建分支后，由于新建立的分支还未在git上，所以push的时候，需要用命令：git push –set-upstream origin hexo。</p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先使用git branch -a查看当前所有分支。</span><br><span class="line">删除本地分支：git branch -d 分支1[,分支名2,分支名3...]</span><br><span class="line">删除远程分支: git push origin --delete 分支名1[,分支命2,分支名...]</span><br></pre></td></tr></table></figure>

<p>注：删除分支时，当前分支不能停留在要删除的分支上，要切换到其他任意分支，再去删除目标分支</p>
<h3 id="缓存分支修改"><a href="#缓存分支修改" class="headerlink" title="缓存分支修改"></a>缓存分支修改</h3><p>​		有时候，我们可能会同时在几个分支上进行开发，在切换分支的时，如果当前分支有修改，这个时候功能还没有全部开发完成，你并不想马上提交到版本库的话，我们可以使用Git提供的缓存修改的命令，把这部分修改暂时缓存起来，切换回这个分支的时候，再把它取出来。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缓存修改命令：git stash </span><br></pre></td></tr></table></figure>
<p>【注：这个命令会把提交到暂存区，就是把使用git add提交之后的代码缓存起来，对未经Git管控的文件修改并不做缓存】</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看缓存列表:git stash list</span><br><span class="line">从缓存中恢复修改并删除缓存内容: git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="同步主分支上的修改"><a href="#同步主分支上的修改" class="headerlink" title="同步主分支上的修改"></a>同步主分支上的修改</h3><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commitId&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>主分支master和feature1分支都同时修改了同一个文件readme.txt，如下图所示：<br><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/git%20img5.png" alt="git img5"></p>
<p>当合并两个分支的时，这个文件就会存在冲突，必须手动解决</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>
<p>可以直接查看readme.txt的内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容。</p>
<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>&emsp; git分为本地仓库和远程仓库，我们一般情况都是写完代码，commit到本地仓库（生成本地仓的commit ID，代表当前提交代码的版本号），然后push到远程仓库（记录这个版本号）。<br>&emsp; 假设我们本地仓库的 master 分支上 commit ID &#x3D;1 ，orign&#x2F;master中的commit ID &#x3D;1 ;这时候远程仓库别人更新了github ogirn库中master分支上的代码，新的代码版本号commit ID &#x3D;2 ,那么在github上 orign&#x2F;master的commitID&#x3D;2，然后我们要更新代码。git流程示意图如下：<br><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/git%20img1.png" alt="git img1"></p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><ul>
<li>使用<code>git fetch</code>更新代码，本地的库中master的commitID不变，还是等于1。但是与git上面关联的那个orign&#x2F;master的commit ID变成了2。这时候本地相当于存储了两个代码的版本号，还要通过<code>git merge orign/master</code>去合并这两个不同的代码版本，如果这两个版本都修改了同一处的代码，这时候merge就会出现冲突，然后我们解决冲突之后就生成了一个新的代码版本。</li>
<li>这时候本地的代码版本可能就变成了commit ID&#x3D;3，即生成了一个新的代码版本。<br><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/git%20img2.png" alt="git img2"></li>
</ul>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><ul>
<li>使用<code>git pull</code>会将最新代码更新到本地，head和remotes中的commitID同时被更新为远程分支最新的commitID。<br><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/git%20img3.png" alt="git img3"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/Git/Git%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80/" data-id="clktuzzfg001wcdoo7gs90o55" data-title="Git命令基础" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux/linux常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/Linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/Linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">linux常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 命令用于查找文件里符合条件的字符串。</p>
<p>查找到符合的内容，就会把含有符合内容的那一列显示出来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;文件内容&quot;</span> 文件名</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><strong>-a 或 –text</strong> : 不要忽略二进制的数据。</li>
<li><strong>-A&lt;显示行数&gt; 或 –after-context&#x3D;&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li>
<li><strong>-b 或 –byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li>
<li><strong>-B&lt;显示行数&gt; 或 –before-context&#x3D;&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li>
<li><strong>-c 或 –count</strong> : 计算符合样式的列数。</li>
<li><strong>-C&lt;显示行数&gt; 或 –context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li>
<li><strong>-d &lt;动作&gt; 或 –directories&#x3D;&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>
<li><strong>-e&lt;范本样式&gt; 或 –regexp&#x3D;&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。</li>
<li><strong>-E 或 –extended-regexp</strong> : 将样式为延伸的正则表达式来使用。</li>
<li><strong>-f&lt;规则文件&gt; 或 –file&#x3D;&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li>
<li><strong>-F 或 –fixed-regexp</strong> : 将样式视为固定字符串的列表。</li>
<li><strong>-G 或 –basic-regexp</strong> : 将样式视为普通的表示法来使用。</li>
<li><strong>-h 或 –no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li>
<li><strong>-H 或 –with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li>
<li><strong>-i 或 –ignore-case</strong> : 忽略字符大小写的差别。</li>
<li><strong>-l 或 –file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li>
<li><strong>-L 或 –files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li>
<li><strong>-n 或 –line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li>
<li><strong>-o 或 –only-matching</strong> : 只显示匹配PATTERN 部分。</li>
<li><strong>-q 或 –quiet或–silent</strong> : 不显示任何信息。</li>
<li><strong>-r 或 –recursive</strong> : 此参数的效果和指定”-d recurse”参数相同。</li>
<li><strong>-s 或 –no-messages</strong> : 不显示错误信息。</li>
<li><strong>-v 或 –invert-match</strong> : 显示不包含匹配文本的所有行。</li>
<li><strong>-V 或 –version</strong> : 显示版本信息。</li>
<li><strong>-w 或 –word-regexp</strong> : 只显示全字符合的列。</li>
<li><strong>-x –line-regexp</strong> : 只显示全列符合的列。</li>
<li><strong>-y</strong> : 此参数的效果和指定”-i”参数相同。</li>
</ul>
<p>此外，如果想要搜索以某些字符结尾的字段，可以加上<code>$</code>符号匹配结尾，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;xxx.conf$&quot;</span> *</span><br></pre></td></tr></table></figure>



<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [option] <span class="string">&#x27;&#123;pattern[action]&#125;&#x27;</span> &#123;filenames&#125;   <span class="comment"># 行匹配语句 awk &#x27;&#x27; 只能用单引号\</span></span><br><span class="line"><span class="comment">#awk 参数 &#x27;&#123;模式[条件动作]&#125;&#x27; 文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Action指的是动作，awk擅长文本格式化，且输出格式化后的结果，因此最常用的动作就是<strong>打印动作</strong><code>print</code>和<code>printf</code></li>
</ul>
<h3 id="awk场景"><a href="#awk场景" class="headerlink" title="awk场景"></a>awk场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat test</span><br><span class="line">#Fields:id      language        language_id     language_name</span><br><span class="line">7       en      1       英语</span><br><span class="line">8       hu      2       匈牙利语</span><br><span class="line">9       fr      4       法语</span><br><span class="line">10      ro      8       罗马尼亚语</span><br><span class="line">11      it      16      意大利语</span><br><span class="line">12      id      32      印度尼西亚语</span><br><span class="line">13      es      64      西班牙语</span><br></pre></td></tr></table></figure>

<p>执行命令<code>awk &#39;&#123;print $1&#125; test&#39;</code>，结果输出第一列信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>awk默认以<strong>空格</strong>为分隔符，且多个空格也识别为一个空格，作为分隔符；</p>
<p>awk是<strong>按行处理文件</strong>，一行处理完毕，接着处理下一行，根据用户指定的分隔符去工作，没有指定则默认空格。</p>
<ul>
<li><code>$0</code>表示整行，又因为awk按行处理，所以<code>print $0</code>会输出全部内容，<code>$1</code>表示第一列。</li>
<li><code>$(NF)</code>表示当前分割后的最后一列，<code>$(NF-1)</code>表示倒数第二列（必须要加上括号）。</li>
</ul>
<h3 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h3><table>
<thead>
<tr>
<th>内置变量</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>指定分隔符后，当前记录的第n个字段</td>
</tr>
<tr>
<td>$0</td>
<td>完整的输入记录</td>
</tr>
<tr>
<td>FS</td>
<td>字段分隔符，默认是空格</td>
</tr>
<tr>
<td>$NF(number of fields)</td>
<td>分割后，当前行一共有多少个字段</td>
</tr>
<tr>
<td>NR(number of records)</td>
<td>当前记录数，行数</td>
</tr>
</tbody></table>
<ul>
<li>awk的内置变量NR、NF是不用添加$符号的，而要取出该列对应的内容时候，才需要加$符号</li>
</ul>
<h3 id="自定义输出内容"><a href="#自定义输出内容" class="headerlink" title="自定义输出内容"></a>自定义输出内容</h3><p>awk，必须<code>外层单引号</code>，<code>内容双引号</code></p>
<p>内置变量<code>$1</code>，<code>$2</code>都不能添加双引号，否则会识别为文本，尽量别加引号；此外这两个内置变量之间的<strong>逗号</strong>会使得输出以空格为分隔符，不加逗号会没有分隔符。</p>
<ol>
<li><p>自定义输出第N列内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;print &quot;第一列:&quot;$1,&quot;第二列：&quot;$2 &#125;&#x27; test</span><br><span class="line">第一列:#Fields:id 第二列：language</span><br><span class="line">第一列:7 第二列：en</span><br><span class="line">第一列:8 第二列：hu</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义输出文件m~n行内容：设置  模式(条件)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;NR==2,NR==5&#123;print $0&#125;&#x27; test</span><br><span class="line">7       en      1       英语</span><br><span class="line">8       hu      2       匈牙利语</span><br><span class="line">9       fr      4       法语</span><br><span class="line">10      ro      8       罗马尼亚语</span><br></pre></td></tr></table></figure>
</li>
<li><p>给每一行的内容添加行号：添加遍历，NR等于行号，$0表示一整行内容</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;&#123;print NR,$0&#125;&#x27; test</span><br><span class="line">1 #Fields:id    language        language_id     language_name</span><br><span class="line">2 7     en      1       英语</span><br><span class="line">3 8     hu      2       匈牙利语</span><br><span class="line">4 9     fr      4       法语</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="awk参数"><a href="#awk参数" class="headerlink" title="awk参数"></a>awk参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定分隔字段符</td>
</tr>
<tr>
<td>-v</td>
<td>定义或修改一个awk内部的变量</td>
</tr>
<tr>
<td>-f</td>
<td>从脚本文件中读取awk命令</td>
</tr>
</tbody></table>
<ol>
<li><p>FS（field separator）输入分隔符：通过<code>-F</code>参数修改输入的分隔符。</p>
<p>（假设test文本里的字段都是用<code>:</code>分隔的）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F &quot;:&quot; &#x27;&#123;print $1,$(NF-1),$4&#125;&#x27; test</span><br><span class="line">#Fields language_id language_id</span><br><span class="line">#7 1 英语</span><br><span class="line">#8 2 匈牙利语</span><br><span class="line">#9 4 法语</span><br><span class="line">#10 8 罗马尼亚语</span><br></pre></td></tr></table></figure>
</li>
<li><p>OFS(output field separator)输出分隔符：通过<code>-v</code>来修改输出内容的分隔符，<code>$1,$NF</code>之间加上逗号，本应是用空格分隔输出内容，但是通过<code>-v OFS=&quot;---&quot;</code>修改为用<code>---</code>来分隔输出内容。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F &quot;:&quot; -v OFS=&quot;---&quot; &#x27;&#123;print $1,$NF&#125;&#x27; test</span><br><span class="line">#Fields---language_name</span><br><span class="line">#7---英语</span><br><span class="line">#8---匈牙利语</span><br><span class="line">#9---法语</span><br><span class="line">.....</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="awk动作：格式化输出"><a href="#awk动作：格式化输出" class="headerlink" title="awk动作：格式化输出"></a>awk动作：格式化输出</h3><p>awk动作包括两个<strong>打印动作</strong><code>print</code>和<code>printf</code></p>
<p><code>printf</code>命令用于格式化输出，它输出不带换行符，参数如下：</p>
<ul>
<li>%s:字符串</li>
<li>%f:浮点格式（也就是我们概念中的float或者double）</li>
<li>%b:相对应的参数中包含转义字符时，可以使用此替换符进行替换，对应的转义字符会被转义。</li>
<li>%c:ASCII字符。显示相对应参数的第一个字符</li>
<li>%d,:%i:十进制整数</li>
<li>%o:不带正负号的八进制值</li>
<li>%u:不带正负号的十进制值</li>
<li>%x:不带正负号的十六进制值，使用a至f表示10至15</li>
<li>%X:不带正负号的十六进制值，使用A至F表示10至15</li>
<li>%% 表示”%”本身</li>
<li>-:减号代表输出的内容进行左对齐</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN&#123;printf &quot;%-25s\t %-25s\t %-25s\t\n&quot;, &quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;&#125; &#123;printf &quot;%-25s\t%-25s\t%-25s\n&quot;,$2,$3,$4&#125;&#x27; hzh_test</span><br><span class="line">id1                              id2                             id3</span><br><span class="line">en                              1                               英语</span><br><span class="line">hu                              2                               匈牙利语</span><br><span class="line">fr                              4                               法语</span><br><span class="line">ro                              8                               罗马尼亚语</span><br></pre></td></tr></table></figure>



<h3 id="awk模式pattern"><a href="#awk模式pattern" class="headerlink" title="awk模式pattern"></a>awk模式pattern</h3><ol>
<li><p>BEGIN&#x2F;END模式</p>
<p>awk的<code>BEGIN</code>和<code>END</code></p>
<ul>
<li>BEGIN模式是处理文本之前需要执行的操作</li>
<li>END模式是处理完所有行之后执行的操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;BEGIN&#123;print &quot;处理之前开始执行的操作&quot;&#125; &#123;print $0&#125; END&#123;print &quot;所有文本处理完之 后执行的操作&quot;&#125; hzh_test</span><br><span class="line">处理之前开始执行的操作</span><br><span class="line">7       en      1       英语</span><br><span class="line">8       hu      2       匈牙利语</span><br><span class="line">9       fr      4       法语</span><br><span class="line">所有文本处理完之后执行的操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算模式</p>
<p>例子1：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#x27;NR==2,NR==5&#123;print $0&#125;&#x27; test</span><br><span class="line">$ awk &#x27;NR!=2&#123;print $0&#125;&#x27; test</span><br></pre></td></tr></table></figure>
<p>例子2：将某一列的数值相加</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat hzh_test |awk &#x27;&#123;sum += $1&#125; END&#123;print sum&#125;&#x27;</span><br><span class="line">255</span><br></pre></td></tr></table></figure>

</li>
<li><p>空模式</p>
<p>不指定任何模式</p>
</li>
</ol>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>Linux sort命令将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span> [OPTION]… [FILE]…</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong>：</p>
<ul>
<li>-b 忽略每行前面开始出的空格字符。</li>
<li>-c 检查文件是否已经按照顺序排序。</li>
<li>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</li>
<li>-f 排序时，将小写字母视为大写字母。</li>
<li>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。</li>
<li>-m 将几个排序好的文件进行合并。</li>
<li>-M 将前面3个字母依照月份的缩写进行排序。</li>
<li>-n 依照数值的大小排序。</li>
<li>-u 意味着是唯一的(unique)，输出的结果是去完重了的。</li>
<li>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。</li>
<li>-r 以相反的顺序来排序。</li>
<li>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。</li>
<li>+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。</li>
<li>–help 显示帮助。</li>
<li>–version 显示版本信息。</li>
<li>[-k field1[,field2]] 按指定的列进行排序。</li>
</ul>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p>
<p>uniq 可检查文本文件中重复出现的行列。<strong>当重复的行并不相邻时，uniq 命令是不起作用的。</strong></p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uniq</span> [OPTION]… [FILE]…</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-c或–count 在每列旁边显示该行重复出现的次数。</li>
<li>-d或–repeated 仅显示重复出现的行列。</li>
<li>-f&lt;栏位&gt;或–skip-fields&#x3D;&lt;栏位&gt; 忽略比较指定的栏位。</li>
<li>-s&lt;字符位置&gt;或–skip-chars&#x3D;&lt;字符位置&gt; 忽略比较指定的字符。</li>
<li>-u或–unique 仅显示出一次的行列。</li>
<li>-w&lt;字符位置&gt;或–check-chars&#x3D;&lt;字符位置&gt; 指定要比较的字符。</li>
<li>–help 显示帮助。</li>
<li>–version 显示版本信息。</li>
<li>[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；</li>
<li>[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</li>
</ul>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>head 命令可用于查看文件的开头部分的内容，有一个常用的参数 <strong>-n</strong> 用于显示行数，默认为 10，即显示 10 行的内容。</p>
<p><strong>命令格式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> [参数] [文件]  </span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c&lt;数目&gt; 显示的字节数。</li>
<li>-n&lt;行数&gt; 显示的行数。</li>
</ul>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>Linux wc命令用于计算字数。</p>
<p>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p>
<p>在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。使用的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> 文件名</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">wc</span> recommend_redis_conf_file</span><br><span class="line">6  36 864 recommend_redis_conf_file</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li>-c或–bytes或–chars 只显示Bytes数。</li>
<li>-l或–lines 显示行数。</li>
<li>-w或–words 只显示字数。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<p>wc命令常常配合其他命令来用，如：</p>
<ol>
<li><p>查找文件中字符“100”的个数；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;100&quot;</span> 文件名 | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找文件夹里文件的个数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p>
<p>语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]</span><br></pre></td></tr></table></figure>



<p><strong>参数</strong>：</p>
<ul>
<li>-num 一次显示的行数</li>
<li>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声</li>
<li>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</li>
<li>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）</li>
<li>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</li>
<li>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料</li>
<li>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</li>
<li>+&#x2F;pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</li>
<li>+num 从第 num 行开始显示</li>
<li>fileNames 欲显示内容的文档，可为复数个数</li>
</ul>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dirName <span class="comment">#在当前目录下创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p dirName/subName/src <span class="comment">#创建多级目录</span></span><br></pre></td></tr></table></figure>



<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>tail 命令可用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件。</p>
<p><strong>tail -f filename</strong> 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p>
<p><strong>命令格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [参数] [文件]  </span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li>-f 循环读取</li>
<li>-q 不显示处理信息</li>
<li>-v 显示详细的处理信息</li>
<li>-c&lt;数目&gt; 显示的字节数</li>
<li>-n&lt;行数&gt; 显示文件的尾部 n 行内容</li>
<li>–pid&#x3D;PID 与-f合用,表示在进程ID,PID死掉之后结束</li>
<li>-q, –quiet, –silent 从不输出给出文件名的首部</li>
<li>-s, –sleep-interval&#x3D;S 与-f合用,表示在每次反复的间隔休眠S秒</li>
</ul>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p><strong>nohup</strong> 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p>
<p><strong>nohup</strong> 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 <strong>$HOME&#x2F;nohup.out</strong> 文件中。</p>
<p><strong>语法格式:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> Command [ Arg … ] [　&amp; ]</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<p><strong>Command</strong>：要执行的命令。</p>
<p><strong>Arg</strong>：一些参数，可以指定输出文件。</p>
<p>**&amp;**：让命令在后台执行，终端退出后命令仍旧执行。</p>
<p><strong>nohup与&amp;的区别：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> ./start.sh &amp;</span><br><span class="line"><span class="built_in">nohup</span> ./start.sh &amp;&gt;out &amp;  <span class="comment">#第一个&amp;是后台运行它前面的内容，第二个&amp;是运行两个&amp;之间的内容</span></span><br></pre></td></tr></table></figure>

<p>&amp;的意思是在后台运行， 当你在执行 .&#x2F;start.sh &amp; 的时候， 即使你用ctrl C, 那么start.sh照样运行（因为对SIGINT信号免疫）。 但是要注意， 如果你直接关掉shell后， 那么，start.sh进程同样消失。</p>
<p>nohup的意思是忽略SIGHUP信号， 所以当运行nohup .&#x2F;start.sh的时候， 关闭shell, 那么start.sh进程还是存在的（对SIGHUP信号免疫）。 但是， 要注意， 如果你直接在shell中用Ctrl C, 那么start.sh进程也是会消失的（因为对SIGINT信号不免疫）</p>
<p>所以nohup结合&amp;使用，让进程真正不受shell中Ctrl C和shell关闭的影响。</p>
<h2 id="vim设置"><a href="#vim设置" class="headerlink" title="vim设置"></a>vim设置</h2><p>拷贝到linux文本文件中的字符串会被再进行一下缩进。</p>
<p>解决办法：<br>1，在拷贝前输入:set paste (这样的话，vim就不会启动自动缩进，而只是纯拷贝粘贴）<br>2，拷贝完成之后，输入:set nopaste (关闭paste)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/Linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="clktuzzfk001ycdoo58z4cshe" data-title="linux常用命令" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux/实存(RES)与虚存(VIRT)分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/Linux/%E5%AE%9E%E5%AD%98(RES)%E4%B8%8E%E8%99%9A%E5%AD%98(VIRT)%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/Linux/%E5%AE%9E%E5%AD%98(RES)%E4%B8%8E%E8%99%9A%E5%AD%98(VIRT)%E5%88%86%E6%9E%90/">实存(RES)与虚存(VIRT)分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/linux_top.png" alt="linux_top"></p>
<p>VIRT：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；</span><br><span class="line">2、假如进程新申请10MB的内存，但实际只使用了1MB，那么它会增长10MB，而不是实际的1MB使用量。</span><br><span class="line">3、VIRT = SWAP + RES</span><br></pre></td></tr></table></figure>



<p>RES:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、进程当前使用的内存大小，包括使用中的malloc、new分配的堆空间和分配的栈空间，但不包括swap out量；</span><br><span class="line">2、包含其他进程的共享；</span><br><span class="line">3、如果申请10MB的内存，实际使用1MB，它只增长1MB，与VIRT相反；</span><br><span class="line">4、关于库占用内存的情况，它只统计加载的库文件所占内存大小。</span><br><span class="line">5、RES = CODE + DATA</span><br></pre></td></tr></table></figure>



<p>SHR:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、除了自身进程的共享内存，也包括其他进程的共享内存；</span><br><span class="line">2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小；</span><br><span class="line">3、计算某个进程所占的物理内存大小公式：RES – SHR；</span><br><span class="line">4、swap out后，它将会降下来。</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>堆、栈分配的内存，如果没有使用是不会占用实存的，只会记录到虚存。</li>
<li>如果程序占用实存比较多，说明程序申请内存多，实际使用的空间也多。</li>
<li>如果程序占用虚存比较多，说明程序申请来很多空间，但是没有使用。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/Linux/%E5%AE%9E%E5%AD%98(RES)%E4%B8%8E%E8%99%9A%E5%AD%98(VIRT)%E5%88%86%E6%9E%90/" data-id="clktuzzfn0021cdoogweyh5ks" data-title="实存(RES)与虚存(VIRT)分析" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-docker/docker底层原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/docker/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/docker/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">docker底层原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="docker平台"><a href="#docker平台" class="headerlink" title="docker平台"></a>docker平台</h2><p>docker提供了一种拥有打包和运行在一个隔离环境能力的容器。隔离性和安全性允许你去在一台机器上允许多个容器。容器是轻量级的，并且包含运行应用程序所需的一切环境，因此无需依赖主机上当前安装的内容。</p>
<h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><p>docker使用了一个客户端-服务端的架构。docker客户端与<em>docker守护进程</em>（daemon）通信，后者负责构建、运行和分发docker容器的繁重工作。docker客户端和守护进程可以在同一个系统上运行，或者可以将docker客户端连接到远程docker守护进程。docker客户端和守护进程使用REST API，通过 UNIX 套接字或网络接口进行通信。另一个 Docker 客户端是 Docker Compose，它允许您使用由一组容器组成的应用程序。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/docker%E6%9E%B6%E6%9E%84.png" alt="docker架构"></p>
<h3 id="docker守护进程"><a href="#docker守护进程" class="headerlink" title="docker守护进程"></a>docker守护进程</h3><p>Docker 守护程序 ( <code>dockerd</code>) 侦听 Docker API 请求并管理 Docker 对象，例如图像、容器、网络和卷。守护进程还可以与其他守护进程通信以管理 Docker 服务。</p>
<h3 id="docker-hub（registry）"><a href="#docker-hub（registry）" class="headerlink" title="docker hub（registry）"></a>docker hub（registry）</h3><p>Docker <em>hub</em>存储 Docker 镜像。Docker Hub 是一个任何人都可以使用的公共存储空间，并且 Docker 默认配置为在 Docker Hub 上查找镜像。甚至可以运行自己的私有hub。</p>
<p>当您使用<code>docker pull</code>or<code>docker run</code>命令时，将从你配置的hub中提取所需的镜像。当您使用该<code>docker push</code>命令时，镜像会被推送到你配置的hub中。</p>
<h3 id="docker对象"><a href="#docker对象" class="headerlink" title="docker对象"></a>docker对象</h3><p>当使用 Docker 时，正在创建和使用镜像、容器、网络、卷、插件和其他对象。本节简要概述了其中一些对象。</p>
<h4 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h4><p>镜像是一个只读模板，其中包含创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的自定义，当镜像被命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/docker%E9%95%9C%E5%83%8F%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="docker镜像层结构"></p>
<p>要构建自己的镜像，需要使用简单的语法创建一个<em>Dockerfile</em> ，用于定义创建和运行镜像所需的步骤。Dockerfile 中的每条指令都会在镜像中<strong>创建一个层</strong>(ENV、EXPOSE、CMD、ENTRY-POINT等命令不会创建镜像层，它们会在镜像中添加元数据)，每层都有一个镜像层ID来标识它，可以通过<code>docker image inspect</code>命令来查看细节。当您更改 Dockerfile 并重建镜像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻量、小巧和快速的部分原因。</p>
<p>如下图所示：P89</p>
<p>docker采取分层结构的最大好处就是<strong>共享资源</strong>，比如:<strong>有多个镜像都从相同的 base 镜像构建而来</strong>，那么宿主机只需在磁盘上保存一份 <strong>base</strong> 镜像，同时内存中也只需加载一份 <strong>base</strong> 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是镜像的可运行实例。您可以使用 Docker API 或 客户端 创建、启动、停止、移动或删除容器。你可以将容器连接到一个或多个网络，并将它与存储连接在一起，甚至可以根据其当前状态创建新镜像。</p>
<p>默认情况下，一个容器与其他容器及其主机的隔离相对较好。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。</p>
<p>容器由其镜像以及你在创建或启动它时提供给它的任何配置选项定义。当容器被移除时，任何未存储在持久存储中的状态更改都会消失。（如mysql存储的数据）</p>
<h3 id="示例docker-run命令"><a href="#示例docker-run命令" class="headerlink" title="示例docker run命令"></a>示例<code>docker run</code>命令</h3><p>以下命令运行一个<code>ubuntu</code>容器，以交互方式附加到本地命令行会话，然后运行<code>/bin/bash</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>当运行此命令时，会发生以下情况（假设使用的是默认docker hub配置）：</p>
<ol>
<li>如果在本地没有<code>ubuntu</code>镜像，Docker 会从配置的docker hub中下载它，就像<code>docker pull ubuntu</code>手动运行一样。</li>
<li>Docker 会创建一个新容器，就像您<code>docker container create</code> 手动运行命令一样。</li>
<li>Docker客户端会向Docker daemon发出命令，daemon收到命令后会向containerd发出调用。（daemon已经不再包含任何创建容器的代码了）</li>
<li>接着containerd将Docker镜像转换为OCI bundle，并让runc基于此创建一个新的容器。</li>
<li>然后，runc与操作系统内核接口进行通信，基于所有必要的工具（Namespace、CGroup等）来创建容器。容器进程作为runc的子进程启动，启动完毕后，runc将会退出。</li>
<li>Docker 为容器分配一个读写文件系统（联合文件系统），作为它的最后一层。这允许正在运行的容器在其本地文件系统中创建或修改文件和目录。</li>
<li>Docker 创建了一个网络接口来将容器连接到默认网络，因为没有指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。</li>
<li>Docker 启动容器并执行<code>/bin/bash</code>. 因为容器以交互方式运行并附加到本地的终端（由于<code>-i</code>and<code>-t</code> 标志），所以可以在输出记录到终端时使用键盘提供输入。</li>
<li>当键入<code>exit</code>终止<code>/bin/bash</code>命令时，容器会停止但不会被删除。可以重新启动或删除它。</li>
</ol>
<p>整个过程如下:P45</p>
<h2 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h2><p>Docker 是用Go编程语言编写的，并利用 Linux 内核的几个特性来提供其功能。</p>
<h3 id="命名空间（Namespaces）"><a href="#命名空间（Namespaces）" class="headerlink" title="命名空间（Namespaces）"></a>命名空间（Namespaces）</h3><p>docker使用了一种称为命名空间的技术来提供称为容器的隔离工作区。当您运行容器时，Docker 会为该容器创建一组命名空间。这些命名空间提供了一层隔离。容器的每个方面都在单独的命名空间中运行，并且它的访问权限仅限于该命名空间。</p>
<p>这些命名空间提供了一层隔离。容器的每个方面都在单独的命名空间中运行，并且它的访问权限仅限于该命名空间。</p>
<p>docker引擎在linux下使用了以下这些命名空间：</p>
<ul>
<li><strong>pid</strong>命名空间：进程隔离</li>
<li><strong>net</strong>命名空间：管理网络接口</li>
<li><strong>ipc</strong>命名空间：管理进程间通信的资源（共享内存）</li>
<li><strong>mnt</strong>命名空间：管理文件系统挂载</li>
<li><strong>uts</strong>命名空间：隔离内核和版本定义</li>
</ul>
<p>eg:</p>
<p><code>cd /proc</code>，里面以进程id作为文件名，保存了每一个进程的信息。</p>
<p><code>cd 1和cd 2</code>：进入进程id为1和2的文件里，发现两个文件夹里以上命名空间对应的id是相等的，说明宿主机里的两个进程是在一个命名空间里。</p>
<p><code>docker run -d redis</code>：在宿主机上运行一个redis的容器，再进入到该容器对应的进程文件里，发现容器的命名空间和宿主机进程的命名空间是隔离的。</p>
<h3 id="控制群组（control-groups）"><a href="#控制群组（control-groups）" class="headerlink" title="控制群组（control groups）"></a>控制群组（control groups）</h3><p>Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供<strong>物理资源上的隔离</strong>，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的<em>容器</em>，这些容器却共同占用了宿主机器的物理资源。</p>
<p>docker引擎在linux上也依赖另一个名叫control groups(cgroups)的技术。一个cgroup能限制一个应用程序的一些特定的资源，如cpu、内存、网卡、块设备的读写，也就是限制一个容器使用的资源。</p>
<h3 id="联合文件系统（Union-file-systems）"><a href="#联合文件系统（Union-file-systems）" class="headerlink" title="联合文件系统（Union file systems）"></a>联合文件系统（Union file systems）</h3><p>联合文件系统也叫文件系统，它是通过创建一种层来使它们非常的轻量和快。 docker引擎使用联合文件系统来提供容器的块。docker引擎可以使用多种联合文件系统，包含AUFS，btrfs，vfs和DeviceMapper。</p>
<p>总的来说，文件系统就是把磁盘上存储空间的内容通过一定的形式来展现出来的一个系统。</p>
<h3 id="容器格式（Container-format）"><a href="#容器格式（Container-format）" class="headerlink" title="容器格式（Container format）"></a>容器格式（Container format）</h3><p>docker引擎把命名空间、控制群组、文件系统组合成一个包装器，叫做容器格式。它默认的容器格式叫<strong>libcontainer</strong>。在未来，docker会支持其他一些容器格式。</p>
<h2 id="容器和虚拟机的区别"><a href="#容器和虚拟机的区别" class="headerlink" title="容器和虚拟机的区别"></a>容器和虚拟机的区别</h2><p>与虚拟机模型相同，os也占用了全部硬件资源。在OS层之上，需要安装容器引擎（docker）。容器引擎可以获取系统资源，比如进程树、文件系统以及网络栈，接着将资源分割为安全的互相隔离的资源结构，称之为容器，每一个容器看起来就像一个真实的操作系统，在其内部可以运行应用。<br>P70</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/docker/docker%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" data-id="clktuzzfp0024cdoohb9q608f" data-title="docker底层原理" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-docker/使用docker搭建go开发环境" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/docker/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/docker/">docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/docker/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/">使用docker搭建go开发环境</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么使用docker"><a href="#为什么使用docker" class="headerlink" title="为什么使用docker"></a>为什么使用docker</h2><ul>
<li>可以保持系统软件环境的纯净。</li>
<li>开发环境和当前使用系统不再强依赖。无论系统再怎么升级，都不会再影响到我的开发环境。</li>
<li>开发软件的管理方式更加统一。各种编程语言都有各自的安装流程和步骤，各种应用服务的安装和配置方式也千差万别。通过 Docker，从一个更高的维度抽象和统一了这些差异。不论是 MySQL，还是 Redis，我都只需要拉镜像，映射端口，然后启动容器就行了。</li>
</ul>
<h2 id="搭建方法一"><a href="#搭建方法一" class="headerlink" title="搭建方法一"></a>搭建方法一</h2><h3 id="测试镜像"><a href="#测试镜像" class="headerlink" title="测试镜像"></a>测试镜像</h3><p>使用docker来构建开发环境的第一步就是先找镜像。在 docker hub 上就有 Go 语言的官方镜像：<strong>golang</strong>，先用下面的命令测试一下这个镜像。</p>
<p><code>docker run --rm golang:alpine go version</code></p>
<ul>
<li>这条命令以 <code>go</code> 为分界线，前面的部分属于 docker，表示执行 <strong>golang</strong> 镜像容器。 <code>alpine</code> 是这个镜像的标签，我个人喜欢 <strong>alpine</strong> 的小巧，所以选择的这个。</li>
<li><code>--rm</code> 参数表示执行完成后就删除容器，避免浪费存储空间。</li>
</ul>
<h3 id="执行go代码"><a href="#执行go代码" class="headerlink" title="执行go代码"></a>执行go代码</h3><p>上面的 go 命令虽然可以执行了，不过还不能运行 go 代码文件。因为还没提供目录挂载功能。自定义的 Shell 脚本内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker run --rm \</span><br><span class="line">    -v $PWD:/srv/app \</span><br><span class="line">    -w /srv/app \</span><br><span class="line">    golang:alpine myTest</span><br></pre></td></tr></table></figure>
<ul>
<li>myTest是编译好的go程序。</li>
<li><code>-v</code> 将宿主主机目录挂在到容器里。<code>$PWD</code> 代表当前执行命令的位置，即宿主机目录，<code>/srv/app</code> 是镜像容器中的目录。</li>
<li><code>-w</code> Docker 设置容器运行时的工作主目录。这主要是为了配合上面的 <code>-v</code> 参数来执行当前目录下的 go 代码</li>
</ul>
<p>注释：**将宿主机目录挂载到容器里 **   这句话可以理解成   把容器想成一个单独的系统，或者说电脑，而你的宿主机目录是一个U盘，挂载后，你往宿主机该目录里放文件，那么通过容器里对应目录便可以访问到此文件，不需要重新生成容器就可以在“容器外部”添加和修改某些文件。</p>
<h3 id="修改go环境变量"><a href="#修改go环境变量" class="headerlink" title="修改go环境变量"></a>修改go环境变量</h3><p>Go 可以通过环境变量的方式来配置镜像，Docker 也支持设置容器运行时的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker run --rm \</span><br><span class="line">	-e GOPROXY=https://goproxy.cn \</span><br><span class="line">    -v $PWD:/srv/app \</span><br><span class="line">    -w /srv/app \</span><br><span class="line">    golang:alpine myTest</span><br></pre></td></tr></table></figure>

<p>添加了一个 <code>-e</code> 参数，这是 Docker 用来设置容器运行时的环境变量，通过这个参数把后面 Go 的镜像家属配置带入运行的容器。</p>
<h2 id="搭建方法二"><a href="#搭建方法二" class="headerlink" title="搭建方法二"></a>搭建方法二</h2><p>编写Dockerfile文件，通过文件来创建镜像</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用基础镜像来创建我们的镜像，后续的指令都基于该基础镜像环境运行</span></span><br><span class="line"><span class="keyword">FROM</span> golang:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为我们的镜像设置必要的环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> GO111MODULE=on \</span><br><span class="line">    CGO_ENABLED=<span class="number">0</span> \</span><br><span class="line">    GOOS=linux \</span><br><span class="line">    GOARCH=amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到容器中的工作目录：/build</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地代码复制到容器中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将我们的代码编译成二进制可执行文件http_mytest</span></span><br><span class="line"><span class="comment"># 下载gin依赖包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod init build</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -u github.com/gin-gonic/gin</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o http_mytest .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到容器中用于存放生成的二进制文件的 /dist 目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /dist</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将二进制文件从 /build 目录复制到这里</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> /build/http_mytest .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明服务端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行镜像（启动容器）时运行的命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/dist/http_mytest&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>FROM:文件的开始</p>
<p>FROM centos	#使用centos为系统，若没有则拉取</p>
</li>
<li><p>LABEL：相当于注释或者说明信息</p>
<p>LABEL version&#x3D;”1.0”</p>
<p>LABEL author&#x3D;”xxx”</p>
</li>
<li><p>RUN:执行命令，每执行一条RUN，就会多一层，<strong>所有RUN使用&amp;&amp;连接多个命令一起执行</strong></p>
<p>RUN yum -y update</p>
</li>
<li><p>WORKDIR:在容器中进入或创建目录</p>
<p>WORKDIR &#x2F;test</p>
</li>
<li><p>ADD：将本地文件添加到镜像里</p>
<p>ADD可以解压缩文件</p>
<p>ADD  hello &#x2F;	# 把hello添加到镜像里的根目录</p>
<p>ADD xxx.tar.gz &#x2F;	#添加并解压到根目录</p>
</li>
<li><p>COPY：将本地文件添加到镜像里</p>
<p>WORKDIR &#x2F;root&#x2F;test</p>
<p>COPY hello .	# &#x2F;root&#x2F;test&#x2F;hello</p>
</li>
<li><p>ENV：</p>
<p>ENV MYSQL_VERSION 5.6	# 设置常量</p>
<p>RUN apt-get -y install mysql-server&#x3D;”{MYSQL_VERSION}”</p>
</li>
<li><p>CMD and ENTRYPOINT</p>
<p>CMD [“python”, “app.py”]</p>
<p>若docker指定了其他命令，CMD会被忽略</p>
<p>若定义多个CMD，只会执行最后一个CMD</p>
</li>
</ul>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在项目目录下，执行下面的命令创建镜像，并指定镜像名称为<code>goweb_app</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t rerank_service:v0.0.1 .</span><br></pre></td></tr></table></figure>

<ul>
<li>-t：给镜像加一个Tag</li>
<li><code>rerank_service</code>是镜像名</li>
<li><code>v0.0.1</code>是tag名</li>
<li><code>.</code> 表示当前目录，即Dockerfile所在目录</li>
</ul>
<p>现在我们已经准备好了镜像，但是目前它什么也没做。我们接下来要做的是运行我们的镜像，以便它能够处理我们的请求。运行中的镜像称为容器。</p>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><p>执行下面的命令来运行镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -d -p 8888:8888 goweb_http</span><br></pre></td></tr></table></figure>

<p><code>-d</code>是让该容器运行在后台。</p>
<p>标志位<code>-p</code>用来定义端口绑定。由于容器中的应用程序在端口8888上运行，我们将其绑定到主机端口也是8888。如果要绑定到另一个端口，则可以使用<code>-p $HOST_PORT:8888</code>。例如<code>-p 5000:8888</code>。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>执行下面命令来进入到Dockerfile中拉取的基础镜像环境中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dist <span class="comment">#ls</span></span><br><span class="line">http_mytest</span><br></pre></td></tr></table></figure>



<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure>

<p>-f：实时打印日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs --<span class="built_in">tail</span> 50 容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/docker/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAgo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" data-id="clktuzzfq0026cdoo4ln739jp" data-title="使用docker搭建go开发环境" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-k8s/k8s简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/k8s/k8s%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/k8s/">k8s</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/k8s/k8s%E7%AE%80%E4%BB%8B/">k8s简介</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：</p>
<ul>
<li><p>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器。</p>
</li>
<li><p>当并发访问量变大的时候，怎么样做到横向扩展容器数量。</p>
</li>
</ul>
<p>这些容器管理的问题统称为容器编排问题。</p>
<h2 id="编排系统的需求催生-Kubernetes"><a href="#编排系统的需求催生-Kubernetes" class="headerlink" title="编排系统的需求催生 Kubernetes"></a>编排系统的需求催生 Kubernetes</h2><p>尽管Docker为容器化的应用程序提供了开放标准，但随着容器越来越多出现了一系列新问题：</p>
<ul>
<li>如何协调和调度这些容器？</li>
<li>如何在升级应用程序时不会中断服务？</li>
<li>如何监视应用程序的运行状况？</li>
<li>如何批量重新启动容器里的程序？</li>
</ul>
<p>解决这些问题需要容器编排技术，可以将众多机器抽象，对外呈现出一台超大机器。现在业界比较流行的有：Kubernetes 、Mesos、Docker Swarm。</p>
<p>在业务发展初期只有几个微服务，这时用 Docker 就足够了，但随着业务规模逐渐扩大，容器越来越多，运维人员的工作越来越复杂，这个时候就需要编排系统解救。</p>
<h2 id="Kubernetes-解决的核心问题"><a href="#Kubernetes-解决的核心问题" class="headerlink" title="Kubernetes 解决的核心问题"></a>Kubernetes 解决的核心问题</h2><ul>
<li><p>自我修复：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器。</p>
</li>
<li><p>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整。</p>
</li>
<li><p>服务发现：服务可以通过自动发现的形式找到它所依赖的服务。</p>
</li>
<li><p>负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡。</p>
</li>
<li><p>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本。</p>
</li>
<li><p>存储编排：可以根据容器自身的需求自动创建存储卷。</p>
</li>
</ul>
<p>Kubernetes 的出现不仅主宰了容器编排的市场，更改变了过去的运维方式，不仅将开发与运维之间边界变得更加模糊，而且让 DevOps 这一角色变得更加清晰，每一个软件工程师都可以通过 <a href="https://link.juejin.cn/?target=http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&mid=2247510899&idx=1&sn=6c136480f2812261681309aeac17d73e&chksm=e918ce6fde6f4779a86d1f78fd123310614a1ae895e8a3bece27c68f7f434e86a4a65746637e&scene=21%23wechat_redirect">Kubernetes</a> 来定义服务之间的拓扑关系、线上的节点个数、资源使用量并且能够快速实现水平扩容、蓝绿部署等在过去复杂的运维操作。</p>
<h2 id="Kubernetes-架构和组件"><a href="#Kubernetes-架构和组件" class="headerlink" title="Kubernetes  架构和组件"></a>Kubernetes  架构和组件</h2><p>Kubernetes 由众多组件组成，组件间通过 API 互相通信，归纳起来主要分为三个部分：</p>
<ul>
<li>controller manager</li>
<li>nodes</li>
<li>pods</li>
</ul>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/k8s%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="k8s集群架构图"></p>
<ul>
<li><p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制。</p>
</li>
<li><p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上。</p>
</li>
<li><p><strong>Controller Manager</strong>：即控制管理器集合，这些控制器都具有一种名为控制循环（control loop）的机制，这个机制的功能简单来讲就是负责保持集群中对象的实际状态与期望状态保持一致（用于调度程序以及节点状态检测）。</p>
</li>
<li><p><strong>Etcd</strong> ：负责存储集群中各种资源对象的信息。</p>
</li>
<li><p><strong>Nodes</strong>：构成了Kubernetes集群的集体计算能力，实际部署容器运行的地方。</p>
</li>
<li><p><strong>Pods</strong>：Kubernetes集群中资源的最小单位，可以包含一个或多个容器。</p>
</li>
<li><p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器。</p>
</li>
<li><p><strong>kube-proxy</strong>：每个node节点都有一个组件kube-proxy，实际上是为service服务的，通过kube-proxy，实现流量从service到pod的转发，kube-proxy也可以实现简单的<strong>负载均衡</strong>功能。</p>
</li>
</ul>
<p>Kubernetes 遵循非常传统的客户端&#x2F;服务端的架构模式，客户端可以通过 RESTful 接口或者直接使用 kubectl 与 <a href="https://link.juejin.cn/?target=http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&mid=2247499493&idx=3&sn=4453fb452640045f0b7a2b020a4de61a&chksm=e9189bf9de6f12ef78a70fd575f1e76b377fd454539e94b9e869270a99fb08f48278154be2fa&scene=21%23wechat_redirect">Kubernetes</a> 集群进行通信，这两者在实际上并没有太多的区别，后者也只是对 Kubernetes 提供的 RESTful API 进行封装并提供出来。每一个 <a href="https://link.juejin.cn/?target=http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&mid=2247502359&idx=1&sn=8c16100c9731359b9864403183f44233&chksm=e918af0bde6f261da9f4960c0ed43e1552eeed9ff3ad0ba06bcfef75e3ba9e9d097e1c87a51c&scene=21%23wechat_redirect">Kubernetes</a> 集群都是由一组 Master 节点和一系列的 Worker 节点组成，其中 Master 节点主要负责存储集群的状态并为 Kubernetes 对象分配和调度资源。</p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ul>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中。</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件。</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上。</p>
</li>
<li><p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer。</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务。</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod，pod是kubernetes的最小操作单元，容器必须跑在pod中。</p>
</li>
<li><p>至此，一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理。</p>
</li>
</ul>
<p>这样，外界用户就可以访问集群中的nginx服务了。</p>
<h2 id="Service服务"><a href="#Service服务" class="headerlink" title="Service服务"></a>Service服务</h2><p>在k8s集群中，service是一个抽象概念，它通过一个虚拟的IP映射指定的端口，将代理客户端发来的请求转到后端一组pod中的一个上。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>pod中的容器经常在不停地销毁和重建，因此pod的IP会不停的改变，如果客户端不知道pod的IP已经变化，继续访问之前的IP是无法访问容器。就算客户端知道了pod的IP变化了，每次重建后访问都需要更换IP，效率极为低下。</p>
<h3 id="service代理服务的作用"><a href="#service代理服务的作用" class="headerlink" title="service代理服务的作用"></a>service代理服务的作用</h3><p>这时候就有了service代理服务，类似于nginx代理，作为客户端和pod的中间层，在通过service.yaml 创建service资源后，<strong>随机虚拟创建一个固定的ip和port</strong>，这时候再创建pod，比如deployment类型的nginx，service资源通过Label Selector（标签选择器）查找同名称空间下标签为刚才创建的deployment类型的名字为nginx资源进行绑定，就算pod不停地销毁和重建，并且不管有几个nginx的pod，都会跟这一个固定ip和port绑定，kubernetes内部会时刻更新这组关联关系，客户端访问固定ip和port，后端进行负载均衡机制分别访问不同的nginx的pod。pod的IP会不停的改变，但是service的ip和port不变。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/Pod%E3%80%81RC%E4%B8%8EService%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="Pod、RC与Service的关系"></p>
<p>（ReplicationController 能够动态地创建和销毁 Pod（例如，需要进行扩缩容，或者执行）,保证Service的服务能力和服务质量始终处于预期的标准）</p>
<blockquote>
<p> Service的虚拟IP地址Cluster IP：外部网络无法ping通，只有kubernetes集群内部访问使用,但可以在各个node节点上直接通过ClusterIP:port访问。 </p>
</blockquote>
<h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>Deployment是K8s用于管理Pod的资源对象，用来保证K8s中Pod的多实例、高可用与滚动更新、灰度部署等。可以说，Deployment是K8s中最常用最有用的一个对象，多用来发布无状态的应用。Deployment 其实并不是直接控制 Pod 的，而是借助 ReplicaSet 来控制 Pod 的。</p>
<h3 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h3><p>ReplicaSet 是 kubernetes 中的一种副本控制器资源，主要用于控制由其管理的Pod，使Pod副本的数量始终维持在预设的个数。</p>
<h3 id="Deployment的两大功能"><a href="#Deployment的两大功能" class="headerlink" title="Deployment的两大功能"></a>Deployment的两大功能</h3><ul>
<li><p>水平扩展 &#x2F; 收缩：Deployment Controller 只需要修改它所控制的 ReplicaSet 的 Pod 副本个数就可以了。比如，把这个值从 3 改成 4，那么 Deployment 所对应的 ReplicaSet，就会根据修改后的值自动创建一个新的 Pod。这就是“水平扩展”了；“水平收缩”则反之。</p>
</li>
<li><p>滚动更新：应用的发布和升级是运维最重要的核心职能之一，那么部署在K8S中的应用是怎么发布升级的呢？其实，你只要编辑修改下 Deployment 的 yaml 文件中镜像版本号，再 apply 一下，就更新成功了。</p>
</li>
</ul>
<h3 id="Deployment常用字段解释"><a href="#Deployment常用字段解释" class="headerlink" title="Deployment常用字段解释"></a>Deployment常用字段解释</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>			<span class="comment"># API群组和版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>			<span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>				<span class="comment"># 资源名称，名称空间中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>		        <span class="comment"># 名称空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">minReadySeconds</span> <span class="string">&lt;integer&gt;</span>		<span class="comment"># Pod就绪后多少秒后没有容器crash才视为“就绪”</span></span><br><span class="line">  <span class="string">replicas</span> <span class="string">&lt;integer&gt;</span>			<span class="comment"># Pod副本数，默认为1</span></span><br><span class="line">  <span class="string">selector</span> <span class="string">&lt;object&gt;</span>			<span class="comment"># 标签选择器，必须和template字段中Pod的标签一致</span></span><br><span class="line">  <span class="string">template</span> <span class="string">&lt;object&gt;</span>			<span class="comment"># 定义Pod模板</span></span><br><span class="line"></span><br><span class="line">  <span class="string">revisionHistoryLimit</span> <span class="string">&lt;integer&gt;</span>	<span class="comment"># 滚动更新历史记录数量，默认为10</span></span><br><span class="line">  <span class="string">strategy</span> <span class="string">&lt;Object&gt;</span>			<span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="string">type</span> <span class="string">&lt;string&gt;</span>			<span class="comment"># 滚动更新类型，默认为RollingUpdate</span></span><br><span class="line">    <span class="string">rollingUpdate</span> <span class="string">&lt;Object&gt;</span>		<span class="comment"># 滚动更新参数，只能用于RollingUpdate类型</span></span><br><span class="line">      <span class="string">maxSurge</span> <span class="string">&lt;string&gt;</span>			<span class="comment"># 更新期间可以比replicas定义的数量多出的数量或比例</span></span><br><span class="line">      <span class="string">maxUnavailable</span> <span class="string">&lt;string&gt;</span>		<span class="comment"># 更新期间可以比replicas定义的数少的数量或比例 </span></span><br><span class="line">  <span class="string">progressDeadlineSeconds</span> <span class="string">&lt;integer&gt;</span>	<span class="comment"># 滚动更新故障超时时长，默认为600秒</span></span><br><span class="line">  <span class="string">paused</span> <span class="string">&lt;boolean&gt;</span>			<span class="comment"># 是否暂停部署</span></span><br></pre></td></tr></table></figure>



<h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><p>要理解ingress，需要区分两个概念，ingress和ingress-controller：</p>
<p><strong>ingress对象：</strong> 指的是k8s中的一个api对象，一般用yaml配置。作用是定义请求如何转发到service的规则，可以理解为配置模板。</p>
<p><strong>ingress-controller：</strong> 具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发。</p>
<h3 id="ingress工作原理"><a href="#ingress工作原理" class="headerlink" title="ingress工作原理"></a>ingress工作原理</h3><p>ingress controller通过和kubernetes api交互，动态的去感知集群中ingress规则变化，然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置，再写到nginx-ingress-controller的pod里，这个Ingress controller的pod里运行着一个Nginx服务，控制器会把生成的nginx配置写入&#x2F;etc&#x2F;nginx.conf文件中，然后reload一下使配置生效。以此达到域名分配置和动态更新的问题。</p>
<h3 id="ingress的实现方式"><a href="#ingress的实现方式" class="headerlink" title="ingress的实现方式"></a>ingress的实现方式</h3><p>ingress-controller并不是k8s自带的组件，实际上ingress-controller只是一个统称，用户可以选择不同的ingress-controller实现，目前，由k8s维护的ingress-controller只有google云的GCE与ingress-nginx两个，其他还有很多第三方维护的ingress-controller。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/k8s/k8s%E7%AE%80%E4%BB%8B/" data-id="clktuzzfr0029cdoobthcc72s" data-title="k8s简介" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-k8s/informer/informer机制组件delta_fifo源码解读" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/k8s/informer/informer%E6%9C%BA%E5%88%B6%E7%BB%84%E4%BB%B6delta_fifo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/k8s/">k8s</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/k8s/informer/informer%E6%9C%BA%E5%88%B6%E7%BB%84%E4%BB%B6delta_fifo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">informer机制组件delta_fifo源码解读</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>delta_fifo.go文件路径：kubernetes\staging\src\k8s.io\client-go\tools\cache</p>
<p>DeltaFIFO 是 Kubernetes <strong>客户端库</strong>（client-go）中的一种数据结构，用于存储资源对象的队列。</p>
<h2 id="FIFO结构"><a href="#FIFO结构" class="headerlink" title="FIFO结构"></a>FIFO结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeltaType is the type of a change (addition, deletion, etc)</span></span><br><span class="line"><span class="keyword">type</span> DeltaType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Change type definition</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Added   DeltaType = <span class="string">&quot;Added&quot;</span></span><br><span class="line">	Updated DeltaType = <span class="string">&quot;Updated&quot;</span></span><br><span class="line">	Deleted DeltaType = <span class="string">&quot;Deleted&quot;</span></span><br><span class="line">	<span class="comment">// Replaced is emitted when we encountered watch errors and had to do a</span></span><br><span class="line">	<span class="comment">// relist. We don&#x27;t know if the replaced object has changed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> Previous versions of DeltaFIFO would use Sync for Replace events</span></span><br><span class="line">	<span class="comment">// as well. Hence, Replaced is only emitted when the option</span></span><br><span class="line">	<span class="comment">// EmitDeltaTypeReplaced is true.</span></span><br><span class="line">	Replaced DeltaType = <span class="string">&quot;Replaced&quot;</span></span><br><span class="line">	<span class="comment">// Sync is for synthetic events during a periodic resync.</span></span><br><span class="line">	Sync DeltaType = <span class="string">&quot;Sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Delta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type   DeltaType</span><br><span class="line">	Object <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deltas is a list of one or more &#x27;Delta&#x27;s to an individual object.</span></span><br><span class="line"><span class="comment">// The oldest delta is at index 0, the newest delta is the last one.</span></span><br><span class="line"><span class="keyword">type</span> Deltas []Delta</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// lock/cond protects access to &#x27;items&#x27; and &#x27;queue&#x27;.</span></span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">	cond sync.Cond</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `items` maps a key to a Deltas.</span></span><br><span class="line">	<span class="comment">// Each such Deltas has at least one Delta.</span></span><br><span class="line">	items <span class="keyword">map</span>[<span class="type">string</span>]Deltas</span><br><span class="line"></span><br><span class="line">	<span class="comment">// `queue` maintains FIFO order of keys for consumption in Pop().</span></span><br><span class="line">	<span class="comment">// There are no duplicates in `queue`.</span></span><br><span class="line">	<span class="comment">// A key is in `queue` if and only if it is in `items`.</span></span><br><span class="line">	queue []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// populated is true if the first batch of items inserted by Replace() has been populated</span></span><br><span class="line">	<span class="comment">// or Delete/Add/Update/AddIfNotPresent was called first.</span></span><br><span class="line">	populated <span class="type">bool</span></span><br><span class="line">	<span class="comment">// initialPopulationCount is the number of items inserted by the first call of Replace()</span></span><br><span class="line">	initialPopulationCount <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// keyFunc is used to make the key used for queued item</span></span><br><span class="line">	<span class="comment">// insertion and retrieval, and should be deterministic.</span></span><br><span class="line">	keyFunc KeyFunc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// knownObjects list keys that are &quot;known&quot; --- affecting Delete(),</span></span><br><span class="line">	<span class="comment">// Replace(), and Resync()</span></span><br><span class="line">	knownObjects KeyListerGetter</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Used to indicate a queue is closed so a control loop can exit when a queue is empty.</span></span><br><span class="line">	<span class="comment">// Currently, not used to gate any of CRUD operations.</span></span><br><span class="line">	closed <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// emitDeltaTypeReplaced is whether to emit the Replaced or Sync</span></span><br><span class="line">	<span class="comment">// DeltaType when Replace() is called (to preserve backwards compat).</span></span><br><span class="line">	emitDeltaTypeReplaced <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Called with every object if non-nil.</span></span><br><span class="line">	transformer TransformFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FIFO就是一个队列，主要存储k8s中资源的一些事件，比较重要的变量就是<code>items</code>和<code>queue</code>，比如：创建了一个pod就是一个事件，该事件首先拥有一个key，存放在<code>queue</code>这个数组中，同时在<code>items</code>这个map中也有对应的一个key；</p>
<p><code>items</code>这个map的value是一个deltas，它中的<code>Object</code>就是一个类似pod、service等事件对象；<code>Type</code>就是该事件的类型，比如增加、更新、删除等。</p>
<p><code>deltas</code>这个数组的<code>Object</code>都是一样的，不一样的是它们的类型<code>Type</code>。</p>
<p><code>knownObjects</code> 存储了 DeltaFIFO 管理的所有对象的标识列表，这些标识符用于识别 Kubernetes 中的不同资源对象，以 Kubernetes 中的 Deployment 对象为例，当 DeltaFIFO 接收到新的 Deployment 对象时，它会从对象中提取唯一标识符（如 Namespace 和 Name），并将其添加到 knownObjects 的标识列表中。</p>
<p><code>knownObjects</code> 主要用于跟踪已知对象的标识符，而 <code>items</code> 则是存储实际的对象和它们的 Delta 更新，并用于计算增量变化。</p>
<h2 id="队列的基础操作"><a href="#队列的基础操作" class="headerlink" title="队列的基础操作"></a>队列的基础操作</h2><p>add、update、delete函数主要是把<strong>事件的add、update、delete操作</strong>放入到队列中，而不是对队列执行add、update、delete操作</p>
<h3 id="Add和update"><a href="#Add和update" class="headerlink" title="Add和update"></a>Add和update</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Add(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	f.populated = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> f.queueActionLocked(Added, obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Update(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	f.populated = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> f.queueActionLocked(Updated, obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> queueActionLocked(actionType DeltaType, obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Every object comes through this code path once, so this is a good</span></span><br><span class="line">	<span class="comment">// place to call the transform func.  If obj is a</span></span><br><span class="line">	<span class="comment">// DeletedFinalStateUnknown tombstone, then the containted inner object</span></span><br><span class="line">	<span class="comment">// will already have gone through the transformer, but we document that</span></span><br><span class="line">	<span class="comment">// this can happen. In cases involving Replace(), such an object can</span></span><br><span class="line">	<span class="comment">// come through multiple times.</span></span><br><span class="line">	<span class="keyword">if</span> f.transformer != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		obj, err = f.transformer(obj)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	oldDeltas := f.items[id]</span><br><span class="line">	newDeltas := <span class="built_in">append</span>(oldDeltas, Delta&#123;actionType, obj&#125;)</span><br><span class="line">	newDeltas = dedupDeltas(newDeltas)	<span class="comment">// 如果最后两个事件是删除事件则进行去重</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(newDeltas) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 把key、deltas插入items，把key追加到queue</span></span><br><span class="line">		<span class="keyword">if</span> _, exists := f.items[id]; !exists &#123;</span><br><span class="line">			f.queue = <span class="built_in">append</span>(f.queue, id)</span><br><span class="line">		&#125;</span><br><span class="line">		f.items[id] = newDeltas</span><br><span class="line">		f.cond.Broadcast()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// This never happens, because dedupDeltas never returns an empty list</span></span><br><span class="line">		<span class="comment">// when given a non-empty list (as it is here).</span></span><br><span class="line">		<span class="comment">// If somehow it happens anyway, deal with it but complain.</span></span><br><span class="line">		<span class="keyword">if</span> oldDeltas == <span class="literal">nil</span> &#123;</span><br><span class="line">			klog.Errorf(<span class="string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; ignoring&quot;</span>, id, oldDeltas, obj)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; breaking invariant by storing empty Deltas&quot;</span>, id, oldDeltas, obj)</span><br><span class="line">		f.items[id] = newDeltas</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;Impossible dedupDeltas for id=%q: oldDeltas=%#+v, obj=%#+v; broke DeltaFIFO invariant by storing empty Deltas&quot;</span>, id, oldDeltas, obj)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先通过<code>f.KeyOf(obj)</code>函数计算该obj的一个key值（keyof函数使用了KeyFunc函数去计算key值）</li>
<li>然后把key、deltas插入FIFO中的<code>items</code>，把key追加到<code>queue</code>队列中</li>
<li><code>f.cond.Broadcast()</code>唤醒其他协程</li>
</ol>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Delete(obj <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	f.populated = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, exists := f.items[id]; !exists &#123;</span><br><span class="line">			<span class="comment">// Presumably, this was deleted when a relist happened.</span></span><br><span class="line">			<span class="comment">// Don&#x27;t provide a second report of the same deletion.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// We only want to skip the &quot;deletion&quot; action if the object doesn&#x27;t</span></span><br><span class="line">		<span class="comment">// exist in knownObjects and it doesn&#x27;t have corresponding item in items.</span></span><br><span class="line">		<span class="comment">// Note that even if there is a &quot;deletion&quot; action in items, we can ignore it,</span></span><br><span class="line">		<span class="comment">// because it will be deduped automatically in &quot;queueActionLocked&quot;</span></span><br><span class="line">		_, exists, err := f.knownObjects.GetByKey(id)</span><br><span class="line">		_, itemsExist := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !exists &amp;&amp; !itemsExist &#123;</span><br><span class="line">			<span class="comment">// Presumably, this was deleted when a relist happened.</span></span><br><span class="line">			<span class="comment">// Don&#x27;t provide a second report of the same deletion.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// exist in items and/or KnownObjects</span></span><br><span class="line">	<span class="keyword">return</span> f.queueActionLocked(Deleted, obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>delete操作与add、update略有不同，delete操作会先计算key值，然后判断在<code>f.knownObjects</code>以及<code>f.items</code>是否存在该key值，不存在的话直接执行<code>return nil</code>，不再执行<code>f.queueActionLocked(Deleted, obj)</code></li>
</ol>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Replace(list []<span class="keyword">interface</span>&#123;&#125;, _ <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	keys := <span class="built_in">make</span>(sets.String, <span class="built_in">len</span>(list))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// keep backwards compat for old clients</span></span><br><span class="line">	action := Sync</span><br><span class="line">	<span class="keyword">if</span> f.emitDeltaTypeReplaced &#123;</span><br><span class="line">		action = Replaced</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add Sync/Replaced action for each new item.</span></span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> list &#123;</span><br><span class="line">		key, err := f.KeyOf(item)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> KeyError&#123;item, err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		keys.Insert(key)</span><br><span class="line">		<span class="keyword">if</span> err := f.queueActionLocked(action, item); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;couldn&#x27;t enqueue object: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do deletion detection against objects in the queue</span></span><br><span class="line">	queuedDeletions := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k, oldItem := <span class="keyword">range</span> f.items &#123;</span><br><span class="line">		<span class="keyword">if</span> keys.Has(k) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Delete pre-existing items not in the new list.</span></span><br><span class="line">		<span class="comment">// This could happen if watch deletion event was missed while</span></span><br><span class="line">		<span class="comment">// disconnected from apiserver.</span></span><br><span class="line">		<span class="keyword">var</span> deletedObj <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> n := oldItem.Newest(); n != <span class="literal">nil</span> &#123;</span><br><span class="line">			deletedObj = n.Object</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if the previous object is a DeletedFinalStateUnknown, we have to extract the actual Object</span></span><br><span class="line">			<span class="keyword">if</span> d, ok := deletedObj.(DeletedFinalStateUnknown); ok &#123;</span><br><span class="line">				deletedObj = d.Obj</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		queuedDeletions++</span><br><span class="line">		<span class="keyword">if</span> err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown&#123;k, deletedObj&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.knownObjects != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Detect deletions for objects not present in the queue, but present in KnownObjects</span></span><br><span class="line">		knownKeys := f.knownObjects.ListKeys()</span><br><span class="line">		<span class="keyword">for</span> _, k := <span class="keyword">range</span> knownKeys &#123;</span><br><span class="line">			<span class="keyword">if</span> keys.Has(k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(f.items[k]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			deletedObj, exists, err := f.knownObjects.GetByKey(k)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				deletedObj = <span class="literal">nil</span></span><br><span class="line">				klog.Errorf(<span class="string">&quot;Unexpected error %v during lookup of key %v, placing DeleteFinalStateUnknown marker without object&quot;</span>, err, k)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> !exists &#123;</span><br><span class="line">				deletedObj = <span class="literal">nil</span></span><br><span class="line">				klog.Infof(<span class="string">&quot;Key %v does not exist in known objects store, placing DeleteFinalStateUnknown marker without object&quot;</span>, k)</span><br><span class="line">			&#125;</span><br><span class="line">			queuedDeletions++</span><br><span class="line">			<span class="keyword">if</span> err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown&#123;k, deletedObj&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !f.populated &#123;</span><br><span class="line">		f.populated = <span class="literal">true</span></span><br><span class="line">		f.initialPopulationCount = keys.Len() + queuedDeletions</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeltaFIFO组件刚启动的时候，会向API server做一次全量的查询，假如需要对某个命名空间下所有pod资源进行监听，replace函数的入参<code>list []interface&#123;&#125;</code>就是所有的pod。</p>
<ol>
<li><p>遍历list，每一个item都通过<code>f.KeyOf(item)</code>生成一个key，添加key到<code>set</code>里，并且同add、update接口一样，通过<code>queueActionLocked</code>函数把key插入到队列中</p>
</li>
<li><p>对队列的对象执行删除检测；</p>
</li>
<li><p>判断此时的list的对象是否在客户端的f.knownObjects本地缓存里，不在的话说明客户端本地缓存和服务端ETCD里的值状态不一致，可能是状态同步出错了，则需要往队列增加一个删除操作。</p>
</li>
</ol>
<h3 id="HasSynced"><a href="#HasSynced" class="headerlink" title="HasSynced"></a>HasSynced</h3><p>用于判断 DeltaFIFO 是否已经完成了与 Kubernetes API Server 的同步。具体来说，当 DeltaFIFO 中缓存的所有资源对象都已经被初始化或更新时，HasSynced 方法会返回 true，表示 DeltaFIFO 已经完成了与 Kubernetes API Server 的同步</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> HasSynced() <span class="type">bool</span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">return</span> f.hasSynced_locked()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> hasSynced_locked() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.populated &amp;&amp; f.initialPopulationCount == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要Add&#x2F;Update&#x2F;Delete操作后，就有数据产生了，<code>f.populated</code>就会置为true</p>
<p>以及Replace()插入的第一批事件已经<code>pop</code>出去了，<code>f.initialPopulationCount</code>就会置为true，该函数就返回true，说明已经同步好了。</p>
<h3 id="Resync"><a href="#Resync" class="headerlink" title="Resync"></a>Resync</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Resync() <span class="type">error</span> &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> f.knownObjects == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	keys := f.knownObjects.ListKeys()</span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		<span class="keyword">if</span> err := f.syncKeyLocked(k); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> syncKeyLocked(key <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	obj, exists, err := f.knownObjects.GetByKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		klog.Errorf(<span class="string">&quot;Unexpected error %v during lookup of key %v, unable to queue object for sync&quot;</span>, err, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !exists &#123;</span><br><span class="line">		klog.Infof(<span class="string">&quot;Key %v does not exist in known objects store, unable to queue object for sync&quot;</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we are doing Resync() and there is already an event queued for that object,</span></span><br><span class="line">	<span class="comment">// we ignore the Resync for it. This is to avoid the race, in which the resync</span></span><br><span class="line">	<span class="comment">// comes with the previous value of object (since queueing an event for the object</span></span><br><span class="line">	<span class="comment">// doesn&#x27;t trigger changing the underlying store &lt;knownObjects&gt;.</span></span><br><span class="line">	id, err := f.KeyOf(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> KeyError&#123;obj, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(f.items[id]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := f.queueActionLocked(Sync, obj); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;couldn&#x27;t queue object: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定期调用resync（同步），把本地缓存里的数据再次放到DeltaFIFO中，DeltaFIFO就会消费这些操作。</p>
<h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><p>add、update等方法都是生产者，pop就是消费者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *DeltaFIFO)</span></span> Pop(process PopProcessFunc) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	f.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.lock.Unlock()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(f.queue) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span></span><br><span class="line">			<span class="comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span></span><br><span class="line">			<span class="comment">// Which causes this loop to continue and return from the Pop().</span></span><br><span class="line">			<span class="keyword">if</span> f.closed &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, ErrFIFOClosed</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.cond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		isInInitialList := !f.hasSynced_locked()</span><br><span class="line">		id := f.queue[<span class="number">0</span>]</span><br><span class="line">		f.queue = f.queue[<span class="number">1</span>:]</span><br><span class="line">		depth := <span class="built_in">len</span>(f.queue)</span><br><span class="line">		<span class="keyword">if</span> f.initialPopulationCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">			f.initialPopulationCount--</span><br><span class="line">		&#125;</span><br><span class="line">		item, ok := f.items[id]</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">// This should never happen</span></span><br><span class="line">			klog.Errorf(<span class="string">&quot;Inconceivable! %q was in f.queue but not f.items; ignoring.&quot;</span>, id)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">delete</span>(f.items, id)</span><br><span class="line">		<span class="comment">// Only log traces if the queue depth is greater than 10 and it takes more than</span></span><br><span class="line">		<span class="comment">// 100 milliseconds to process one item from the queue.</span></span><br><span class="line">		<span class="comment">// Queue depth never goes high because processing an item is locking the queue,</span></span><br><span class="line">		<span class="comment">// and new items can&#x27;t be added until processing finish.</span></span><br><span class="line">		<span class="comment">// https://github.com/kubernetes/kubernetes/issues/103789</span></span><br><span class="line">		<span class="keyword">if</span> depth &gt; <span class="number">10</span> &#123;</span><br><span class="line">			trace := utiltrace.New(<span class="string">&quot;DeltaFIFO Pop Process&quot;</span>,</span><br><span class="line">				utiltrace.Field&#123;Key: <span class="string">&quot;ID&quot;</span>, Value: id&#125;,</span><br><span class="line">				utiltrace.Field&#123;Key: <span class="string">&quot;Depth&quot;</span>, Value: depth&#125;,</span><br><span class="line">				utiltrace.Field&#123;Key: <span class="string">&quot;Reason&quot;</span>, Value: <span class="string">&quot;slow event handlers blocking the queue&quot;</span>&#125;)</span><br><span class="line">			<span class="keyword">defer</span> trace.LogIfLong(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">		err := process(item, isInInitialList)</span><br><span class="line">		<span class="keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;</span><br><span class="line">			f.addIfNotPresent(id, item)</span><br><span class="line">			err = e.Err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Don&#x27;t need to copyDeltas here, because we&#x27;re transferring</span></span><br><span class="line">		<span class="comment">// ownership to the caller.</span></span><br><span class="line">		<span class="keyword">return</span> item, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断<code>f.queue</code>中是否有事件，没有则<code>f.cond.Wait()</code>等待，有则逐个取出在<code>process</code>函数中进行消费，此外，如果过程中产生错误，会调用<code>f.addIfNotPresent(id, item)</code>重新插入失败的事件到deltas数组里，然后进行<code>f.cond.Broadcast()</code>广播发信号。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/k8s/informer/informer%E6%9C%BA%E5%88%B6%E7%BB%84%E4%BB%B6delta_fifo%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" data-id="clktuzzgk003ycdoobv0n2h0d" data-title="informer机制组件delta_fifo源码解读" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-k8s/informer/informer简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/k8s/informer/informer%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Kubernetes Informer 是 Kubernetes 中的一种机制，用于监视 Kubernetes API Server 中资源对象的变化，并将这些变化通知给客户端。Informer 可以帮助开发者编写自定义控制器（Custom Controller），并在 Kubernetes 集群中实现自动化操作。</p>
<p>Informer 通过轮询 Kubernetes API Server 来获取资源对象的最新状态，并将其缓存到本地内存中。当资源对象发生变化时，Informer 会检测到这些变化，并将其通知给客户端。这样，客户端就可以及时地响应资源对象的变化，从而实现对 Kubernetes 集群的实时监控和管理。</p>
<p>使用 Informer 可以大大简化开发者编写自定义控制器的工作量，同时提高控制器的性能和可靠性。Informer 还支持多种事件处理方式，例如添加、更新、删除等，可以根据不同的业务需求进行灵活配置。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/k8s/informer/informer%E7%AE%80%E4%BB%8B/" data-id="clktuzzgl0041cdoo65fqfj5l" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/ElasticSearch/Elasticsearch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/Elasticsearch/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.400Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">全文搜索引擎</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/Elasticsearch/">Elasticsearch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>什么是全文搜索引擎？</p>
<blockquote>
<p><strong>百度百科中的定义</strong>： 全文搜索引擎是目前广泛应用的主流搜索引擎。它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>从定义中我们已经可以大致了解全文检索的思路了，为了更详细的说明，我们先从生活中的数据说起。</p>
<p>我们生活中的数据总体分为两种：<strong>结构化数据</strong> 和 <strong>非结构化数据</strong>。</p>
<ul>
<li><strong>结构化数据</strong>： 指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li><strong>非结构化数据</strong>： 非结构化数据又可称为全文数据，指不定长或无固定格式的数据，如邮件，word文档等。</li>
</ul>
<h2 id="使用ES而不是数据库的原因"><a href="#使用ES而不是数据库的原因" class="headerlink" title="使用ES而不是数据库的原因"></a>使用ES而不是数据库的原因</h2><ol>
<li>数据模型：数据库通常采用<strong>结构化数据模型</strong>，使用表格和列来组织和存储数据。ES则采用<strong>面向文档的数据模型</strong>，将数据存储为自包含的JSON文档。这使得ES更适合存储和搜索非结构化或半结构化的数据，如日志、文本文档、地理位置数据等。</li>
<li>搜索和分析能力：ES专注于全文搜索和实时分析，提供强大的搜索、聚合和分析功能。它使用<strong>倒排索引</strong>和<strong>分布式架构</strong>来支持高性能的搜索和复杂的查询操作。相比之下，传统数据库的搜索功能较为有限，对于大规模文本搜索和复杂的聚合查询可能效率较低。</li>
<li>弹性和扩展性：ES具有良好的水平扩展能力，可以轻松地通过添加节点来增加容量和吞吐量。它的分布式架构和自动分片机制使得数据可以并行处理和存储在多个节点上，从而实现高可用性和容错性。传统数据库在处理大规模数据和高并发负载时可能面临性能瓶颈和扩展困难。</li>
<li>实时性：ES提供近实时搜索能力，即文档索引后几乎立即可进行搜索。这使得ES适用于需要快速响应和实时更新的应用场景，如实时日志分析、监控和仪表盘。传统数据库通常具有更高的一致性和事务支持，但在实时性方面可能不如ES。</li>
<li>多种用例支持：ES广泛应用于全文搜索、日志分析、电子商务搜索、内容推荐、地理空间分析等多个领域。它提供了丰富的搜索、聚合和分析功能，以及与Kibana等工具的集成，使得数据探索和可视化更加便捷。传统数据库则更适用于事务处理、关系型数据管理和复杂的数据操作。</li>
</ol>
<p>综上所述，选择使用ES而不是传统数据库的原因在于其强大的搜索和分析能力、良好的扩展性和实时性，以及适用于非结构化或半结构化数据的存储和检索需求。然而，具体选择何种技术取决于应用的特定需求和数据模型。在某些情况下，数据库和ES可以结合使用，以满足不同层次的数据管理和查询需求。</p>
<h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>生成的倒排索引中，词条会排序，形成一颗树形结构，提升词条的查询速度。</p>
<p>如下图所示，查询”华为”会得到对应的value&#x3D;1和3，再通过1和3找到id&#x3D;1和3的文档。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/ElasticSearch%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%90%9C%E7%B4%A2%E5%8E%9F%E7%90%86.png" alt="ElasticSearch数据的存储和搜索原理"></p>
<h2 id="ES基本概念与关系型数据库的比较"><a href="#ES基本概念与关系型数据库的比较" class="headerlink" title="ES基本概念与关系型数据库的比较"></a>ES基本概念与关系型数据库的比较</h2><table>
<thead>
<tr>
<th align="left">ES概念</th>
<th align="left">关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Index（索引）支持全文检索</td>
<td align="left">Database（数据库）</td>
</tr>
<tr>
<td align="left">Type（类型）</td>
<td align="left">Table（表）</td>
</tr>
<tr>
<td align="left">Document（文档），不同文档可以有不同的字段集合</td>
<td align="left">Row（数据行）</td>
</tr>
<tr>
<td align="left">Field（字段）</td>
<td align="left">Column（数据列）</td>
</tr>
<tr>
<td align="left">Mapping（映射）</td>
<td align="left">Schema（模式）</td>
</tr>
</tbody></table>
<h2 id="Elasticsearch-vs-Solr的选择"><a href="#Elasticsearch-vs-Solr的选择" class="headerlink" title="Elasticsearch vs Solr的选择"></a>Elasticsearch vs Solr的选择</h2><p>由于Lucene的复杂性，一般很少会考虑它作为搜索的第一选择，排除一些公司需要自研搜索框架，底层需要依赖Lucene。所以这里我们重点分析 Elasticsearch 和 Solr。</p>
<p>这两个搜索引擎都是流行的，先进的的开源搜索引擎。它们都是围绕核心底层搜索库 - Lucene构建的 - 但它们又是不同的。像所有东西一样，每个都有其优点和缺点，根据您的需求和期望，每个都可能更好或更差。Solr和Elasticsearch都在快速发展，所以，话不多说，先来看下它们的差异清单：</p>
<table>
<thead>
<tr>
<th align="center">特征</th>
<th align="center">Solr&#x2F;SolrCloud</th>
<th align="center">Elasticsearch</th>
</tr>
</thead>
<tbody><tr>
<td align="center">社区和开发者</td>
<td align="center">Apache 软件基金和社区支持</td>
<td align="center">单一商业实体及其员工</td>
</tr>
<tr>
<td align="center">节点发现</td>
<td align="center">Apache Zookeeper，在大量项目中成熟且经过实战测试</td>
<td align="center">Zen内置于Elasticsearch本身，需要专用的主节点才能进行分裂脑保护</td>
</tr>
<tr>
<td align="center">碎片放置</td>
<td align="center">本质上是静态，需要手动工作来迁移分片，从Solr 7开始 - Autoscaling API允许一些动态操作</td>
<td align="center">动态，可以根据群集状态按需移动分片</td>
</tr>
<tr>
<td align="center">高速缓存</td>
<td align="center">全局，每个段更改无效</td>
<td align="center">每段，更适合动态更改数据</td>
</tr>
<tr>
<td align="center">分析引擎性能</td>
<td align="center">非常适合精确计算的静态数据</td>
<td align="center">结果的准确性取决于数据放置</td>
</tr>
<tr>
<td align="center">全文搜索功能</td>
<td align="center">基于Lucene的语言分析，多建议，拼写检查，丰富的高亮显示支持</td>
<td align="center">基于Lucene的语言分析，单一建议API实现，高亮显示重新计算</td>
</tr>
<tr>
<td align="center">DevOps支持</td>
<td align="center">尚未完全，但即将到来</td>
<td align="center">非常好的API</td>
</tr>
<tr>
<td align="center">非平面数据处理</td>
<td align="center">嵌套文档和父-子支持</td>
<td align="center">嵌套和对象类型的自然支持允许几乎无限的嵌套和父-子支持</td>
</tr>
<tr>
<td align="center">查询DSL</td>
<td align="center">JSON（有限），XML（有限）或URL参数</td>
<td align="center">JSON</td>
</tr>
<tr>
<td align="center">索引&#x2F;收集领导控制</td>
<td align="center">领导者安置控制和领导者重新平衡甚至可以节点上的负载</td>
<td align="center">不可能</td>
</tr>
<tr>
<td align="center">机器学习</td>
<td align="center">内置 - 在流聚合之上，专注于逻辑回归和学习排名贡献模块</td>
<td align="center">商业功能，专注于异常和异常值以及时间序列数据</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/Elasticsearch/" data-id="clktuzzgn0043cdoodvgadr56" data-title="Elasticsearch" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-DDD" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/DDD/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.396Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>class Account{</p>
<p>​		方法1：转入</p>
<p>​	   方法2：转出</p>
<p>}</p>
<p>每个实体只能操作自己的属性，而跨实体属性变化必须通过领域服务调度，领域服务不能直接修改实体的状态，只能够调用实体的业务方法。</p>
<p>领域服务：专属当前转账</p>
<p><strong>DDD包含4个层：</strong></p>
<ol>
<li>Domain：这是定义应用程序的领域和业务逻辑的地方</li>
<li>Infrastructure：此层包含独立于我们的应用程序而存在的所有内容：外部库，数据库引擎等。</li>
<li>Application：该层用作领域和界面层之间的通道。将请求从接口层发送到域层，由领域层处理请求并返回响应。</li>
<li>Interface：该层包含与其他系统交互的所有内容，例如Web服务，RMI接口或Web应用程序以及批处理前端。</li>
</ol>
<p>以著名的案例: <a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://github.com/victorsteven/food-app-server">https://github.com/victorsteven/food-app-server</a>为例子</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interfaces git:(master) tree</span><br><span class="line">.</span><br><span class="line">|____fileupload</span><br><span class="line">| |____fileformat.go</span><br><span class="line">| |____fileupload.go</span><br><span class="line">|____food_handler.go</span><br><span class="line">|____food_handler_test.go</span><br><span class="line">|____handler_setup_test.go</span><br><span class="line">|____login_handler.go</span><br><span class="line">|____login_handler_test.go</span><br><span class="line">|____middleware</span><br><span class="line">| |____middleware.go</span><br><span class="line">|____user_handler.go</span><br></pre></td></tr></table></figure>

<p>interfaces层定义了输入层的相关方法，以使用gin提供http接口为例，这里的handler等为使用gin提供的一些http接口（相当于MVC三层中的controller层），这一层会调用application层。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">application git:(master) tree</span><br><span class="line">.</span><br><span class="line">|____food_app.go</span><br><span class="line">|____food_app_test.go</span><br><span class="line">|____user_app.go</span><br><span class="line">|____user_app_test.go</span><br></pre></td></tr></table></figure>

<p>application层主要是调用domain层与infrastructure层来实现功能</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">domain git:(master) tree</span><br><span class="line">.</span><br><span class="line">|____entity</span><br><span class="line">| |____food.go</span><br><span class="line">| |____user.go</span><br><span class="line">|____repository</span><br><span class="line">| |____food_repository.go</span><br><span class="line">| |____user_repository.go</span><br></pre></td></tr></table></figure>

<p>domain层主要是定义了entity，以及repository接口；entity里头会包含一些领域逻辑</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">infrastructure git:(master) tree</span><br><span class="line">.</span><br><span class="line">|____auth</span><br><span class="line">| |____auth.go</span><br><span class="line">| |____redisdb.go</span><br><span class="line">| |____token.go</span><br><span class="line">|____persistence</span><br><span class="line">| |____db.go</span><br><span class="line">| |____food_repository.go</span><br><span class="line">| |____food_repository_test.go</span><br><span class="line">| |____setup_test.go</span><br><span class="line">| |____user_repository.go</span><br><span class="line">| |____user_repository_test.go</span><br><span class="line">|____security</span><br><span class="line">| |____password.go</span><br></pre></td></tr></table></figure>

<p>infrastructure层这里提供了针对domain层的repository接口的实现，还有其他一些基础的组件，提供给application层或者interfaces层使用</p>
<p>小结<br>DDD一般分为interfaces、application、domain、infrastructure这几层；其中domain层不依赖其他层，它定义repository接口，infrastructure层会实现；application层会调用domain、infrastructure层；interfaces层一般调用application层或者infrastructure层。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/DDD/" data-id="clktuzze50001cdoodaibaz66" data-title="" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GO/">GO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E9%9B%85%E5%86%99%E4%BD%9C/">优雅写作</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E9%9B%85%E5%86%99%E4%BD%9C/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">图床搭建</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">全文搜索引擎</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitMap/" rel="tag">BitMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/" rel="tag">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/" rel="tag">vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%A8%E5%85%B5/" rel="tag">哨兵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag">高可用</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BitMap/" style="font-size: 10px;">BitMap</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/C-11/" style="font-size: 10px;">C++11</a> <a href="/tags/MySql/" style="font-size: 13.33px;">MySql</a> <a href="/tags/Redis/" style="font-size: 20px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/go/" style="font-size: 16.67px;">go</a> <a href="/tags/k8s/" style="font-size: 13.33px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/%E5%93%A8%E5%85%B5/" style="font-size: 10px;">哨兵</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 16.67px;">算法</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 10px;">负载均衡</a> <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" style="font-size: 13.33px;">高可用</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/02/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/">nginx</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/Reactor%20%E5%92%8C%20Proactor/">Reactor 和 Proactor</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/">项目代码分层结构</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 pepper<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>