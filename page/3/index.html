<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>胡椒粉的秋天</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="胡椒粉的秋天">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="胡椒粉的秋天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="pepper">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="胡椒粉的秋天" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">胡椒粉的秋天</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-中间件/MySql/MySql索引" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySql/MySql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySql/MySql%E7%B4%A2%E5%BC%95/">MySql索引</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引（在MySQL中也叫“键key”）是存储引擎快速找到记录的一种数据结构。在查询语句select前加上explain命令，可以获取索引执行情况列表。</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>使用<code>show index from 表名;</code>命令可以查看索引详情。</p>
<ol>
<li><p>主键索引primary key：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候使用语句<code>PRIMARY KEY (id) </code>同时创建主键索引。注意：一个表只能有一个主键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `phpcolor_ad` (  </span><br><span class="line">`id` mediumint(8) NOT NULL AUTO_INCREMENT,  </span><br><span class="line">`name` varchar(30) NOT NULL,</span><br><span class="line">PRIMARY KEY (`id`),  </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/MySql%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="MySql主键索引"></p>
<ol start="2">
<li><p>唯一索引 UNIQUE：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一（每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束）。可以通过<code>ALTER TABLE 表名 ADD UNIQUE (列名);</code>创建唯一索引；可以通过<code>ALTER TABLE 表名 ADD UNIQUE (列名1,列名2);</code>；也可以在创建表的时候使用语句<code>KEY type (type)</code>创建索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `phpcolor_ad` (  </span><br><span class="line">`id` mediumint(8) NOT NULL AUTO_INCREMENT,  </span><br><span class="line">`name` varchar(30) NOT NULL,  </span><br><span class="line">`type` mediumint(1) NOT NULL,  </span><br><span class="line">PRIMARY KEY (`id`),  </span><br><span class="line">KEY `type` (`type`)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>创建组合索引结果如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/MySql%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95.png" alt="MySql唯一索引"></p>
<ol start="3">
<li>普通索引 INDEX：这是最基本的索引，它没有任何限制，它与唯一索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。<strong>注意，如果索引是用B+树结构，则B+树的每个叶子节点都是主键值，因为这样可以节省存储空间以及保证一致性</strong>。可以通过<code>ALTER TABLE 表名 ADD INDEX index_name (列名);</code>创建普通索引：</li>
</ol>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/MySql%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95.png" alt="MySql普通索引"></p>
<ol start="4">
<li><p>组合索引 INDEX：即一个索引包含多个列，多用于避免回表查询。可以通过<code>ALTER TABLE 表名 ADD INDEX index_name(column1,column2,column3);</code>创建组合索引，它可以支持最左前缀原则，所以联合索引需要合理安排字段的前后顺序。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%EF%BC%88name%EF%BC%8Cage%EF%BC%89%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="（name，age）索引示意图"></p>
</li>
<li><p>全文索引 FULLTEXT：也称全文检索，是目前搜索引擎使用的一种关键技术。可以通过<code>ALTER TABLE 表名 ADD FULLTEXT (列名);</code>创建全文索引。</p>
</li>
</ol>
<p>索引一经创建不能修改，如果要修改索引，只能删除重建。可以使用<br>DROP INDEX index_name ON table_name;删除索引。</p>
<h2 id="索引设计的原则"><a href="#索引设计的原则" class="headerlink" title="索引设计的原则"></a>索引设计的原则</h2><p>1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列；<br>2）基数较小的类，索引效果较差，没有必要在此列建立索引；<br>3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；<br>4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>有些时候虽然数据库有索引，但是并不被优化器选择使用。我们可以通过SHOW STATUS LIKE ‘Handler_read%’;查看索引的使用情况：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/MySql%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5.png" alt="MySql索引使用情况"></p>
<p><strong>Handler_read_key</strong>：如果索引正在工作，Handler_read_key的值将很高。<br><strong>Handler_read_rnd_next</strong>：数据文件中读取下一行的请求数，如果正在进行大量的表扫描，值将较高，则说明索引利用不理想。</p>
<p>索引优化规则：<br>1）如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。<br>返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。</p>
<p>2）前导模糊查询不能命中索引。<br>假设name列创建了一个普通索引，前导模糊查询不能命中索引：<br><code>EXPLAIN SELECT * FROM user WHERE name LIKE &#39;%s%&#39;;</code></p>
<p><strong>非前导模糊查询则可以使用索引</strong>，可优化为使用非前导模糊查询：<br><code>EXPLAIN SELECT * FROM user WHERE name LIKE &#39;s%&#39;;</code></p>
<p>3）复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。<br>假设name,age,status列创建了复合索引，根据最左原则，可以命中复合索引index_name：<br><code>SELECT * FROM user WHERE name=&#39;swj&#39; AND status=1;</code>。</p>
<p><strong>注意，最左原则并不是说是查询条件的顺序，而是查询条件中是否包含索引最左列字段（如此例子中索引最左列字段是name）。</strong></p>
<p>4）union、in、or都能够命中索引，建议使用in，查询的CPU消耗：or&gt;in&gt;union。</p>
<p>5）用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。</p>
<p>因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。</p>
<p>6）负向条件查询不能使用索引，可以优化为in查询。<br>负向条件有：!&#x3D;、&lt;&gt;、not in、not exists、not like等。</p>
<p>7）范围条件查询可以命中索引。范围条件有：&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;、between等。</p>
<p>9）建立索引的列，不允许为null。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySql/MySql%E7%B4%A2%E5%BC%95/" data-id="clktuzzgo0047cdooh5f68d19" data-title="MySql索引" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/MySql/Sql语句优化的小技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySql/Sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySql/">MySql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySql/Sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/">Sql语句优化的小技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="避免使用select"><a href="#避免使用select" class="headerlink" title="避免使用select*"></a>避免使用select*</h2><h2 id="用union-all代替union"><a href="#用union-all代替union" class="headerlink" title="用union all代替union"></a>用union all代替union</h2><h2 id="小表驱动达标"><a href="#小表驱动达标" class="headerlink" title="小表驱动达标"></a>小表驱动达标</h2><p>小表驱动大表，也就是说用小表的数据集驱动大表的数据集。</p>
<p>假如有order和user两张表，其中order表有10000条数据，而user表有100条数据。</p>
<p>这时如果想查一下，所有有效的用户下过的订单列表。</p>
<p>可以使用<code>in</code>关键字实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from order</span><br><span class="line">where user_id in (select id from user where status=1)</span><br></pre></td></tr></table></figure>

<p>此业务需求用in关键字去实现更加合适，因为如果sql语句中包含了in关键字，则它会优先执行in里面的<code>子查询语句</code>，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。</p>
<h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2><p>如果你有一批数据经过业务处理之后，需要插入数据，该怎么办？</p>
<p>如果在循环中逐条插入数据，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Order order: list)</span><br><span class="line">&#123;</span><br><span class="line">   orderMapper.<span class="built_in">insert</span>(order):</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//insert into order(id,code,user_id) values(123,&#x27;001&#x27;,100);</span></span><br></pre></td></tr></table></figure>

<p>该操作需要多次请求数据库，才能完成这批数据的插入。</p>
<p>这时，提供一个批量插入数据的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderMapper.<span class="built_in">insertBatch</span>(list);</span><br><span class="line"><span class="comment">//insert into order(id,code,user_id) values(123,&#x27;001&#x27;,100),(124,&#x27;002&#x27;,100),(125,&#x27;003&#x27;,101);</span></span><br></pre></td></tr></table></figure>

<p>这样只需要远程请求一次数据库，sql性能会得到提升，数据量越多，提升越大。</p>
<p><strong>但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。</strong></p>
<h2 id="多用limit"><a href="#多用limit" class="headerlink" title="多用limit"></a>多用limit</h2><p>有时候，我们需要查询某些数据中的第一条，比如：查询某个用户下的第一个订单，想看看他第一次的首单时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select id, create_date </span><br><span class="line">from order </span><br><span class="line">where user_id=123 </span><br><span class="line">order by create_date asc </span><br><span class="line">limit 1;</span><br></pre></td></tr></table></figure>

<p>使用<code>limit 1</code>，只返回该用户下单时间最小的那一条数据即可。</p>
<h2 id="in中值太多"><a href="#in中值太多" class="headerlink" title="in中值太多"></a>in中值太多</h2><p>对于批量查询接口，我们通常会使用<code>in</code>关键字过滤出数据。比如：想通过指定的一些id，批量查询出用户信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name from category where id in (1,2,3...100000000);</span><br></pre></td></tr></table></figure>

<p>如果我们不做任何限制，该查询语句一次性可能会查询出非常多的数据，很容易导致接口超时。</p>
<p>所以建议使用limit限制次数，最多500条。</p>
<h2 id="高效的分页"><a href="#高效的分页" class="headerlink" title="高效的分页"></a>高效的分页</h2><p>有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。</p>
<p>在mysql中分页一般用的<code>limit</code>关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age </span><br><span class="line">from user limit 10,20;</span><br></pre></td></tr></table></figure>

<p>如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age </span><br><span class="line">from user limit 1000000,20;</span><br></pre></td></tr></table></figure>

<p>mysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。</p>
<p>海量数据分页应该先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age </span><br><span class="line">from user where id &gt; 1000000 limit 20;</span><br></pre></td></tr></table></figure>

<p>还能使用<code>between</code>优化分页。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age </span><br><span class="line">from user where id between 1000000 and 1000020;</span><br></pre></td></tr></table></figure>

<p>需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。</p>
<h2 id="用连接查询代替子查询"><a href="#用连接查询代替子查询" class="headerlink" title="用连接查询代替子查询"></a>用连接查询代替子查询</h2><p>mysql中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：<code>子查询</code> 和 <code>连接查询</code>。</p>
<p>子查询的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from order</span><br><span class="line">where user_id in (select id from user where status=1)</span><br></pre></td></tr></table></figure>

<p>子查询语句可以通过<code>in</code>关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序先运行在嵌套在最内层的语句，再运行外层的语句。</p>
<p>子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。</p>
<p>但缺点是<strong>mysql执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗</strong>。</p>
<p>这时可以改成连接查询。具体例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select o.* from order o</span><br><span class="line">inner join user u on o.user_id = u.id</span><br><span class="line">where u.status=1</span><br></pre></td></tr></table></figure>



<h2 id="join的表不宜过多"><a href="#join的表不宜过多" class="headerlink" title="join的表不宜过多"></a>join的表不宜过多</h2><p>根据阿里巴巴开发者手册的规定，join表的数量不应该超过<code>3</code>个。</p>
<p>如果join太多，mysql在选择索引的时候会非常复杂，很容易选错索引。</p>
<h2 id="控制索引的数量"><a href="#控制索引的数量" class="headerlink" title="控制索引的数量"></a>控制索引的数量</h2><p>众所周知，索引能够显著的提升查询sql的性能，但索引数量并非越多越好。</p>
<p>因为表中新增数据时，需要同时为它创建索引，而索引是需要额外的存储空间的，而且还会有一定的性能消耗。</p>
<p>阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在<code>5</code>个以内，并且单个索引中的字段数不超过<code>5</code>个。</p>
<p>mysql使用的B+树的结构来保存索引的，在insert、update和delete操作时，需要更新B+树索引。如果索引过多，会消耗很多额外的性能。</p>
<p>那么，问题来了，如果表中的索引太多，超过了5个该怎么办？</p>
<p>这个问题要辩证的看，如果你的系统并发量不高，表中的数据量也不多，其实超过5个也可以，只要不要超过太多就行。</p>
<p>但对于一些高并发的系统，请务必遵守单表索引数量不要超过5的限制。</p>
<p>那么，高并发系统如何优化索引数量？</p>
<p>能够建联合索引，就别建单个索引，可以删除无用的单个索引。</p>
<p>将部分查询功能迁移到其他类型的数据库中，比如：Elastic Seach、HBase等，在业务表中只需要建几个关键索引即可。</p>
<h2 id="选择合理的字段类型"><a href="#选择合理的字段类型" class="headerlink" title="选择合理的字段类型"></a>选择合理的字段类型</h2><p>我们在选择字段类型时，应该遵循这样的原则：</p>
<ol>
<li>能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。</li>
<li>尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。</li>
<li>长度固定的字符串字段，用char类型。</li>
<li>长度可变的字符串字段，用varchar类型。</li>
<li>金额字段用decimal，避免精度丢失问题。</li>
</ol>
<h2 id="提升group-by的效率"><a href="#提升group-by的效率" class="headerlink" title="提升group by的效率"></a>提升group by的效率</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user_id,user_name from order</span><br><span class="line">group by user_id</span><br><span class="line">having user_id &lt;= 200;</span><br></pre></td></tr></table></figure>

<p>这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。</p>
<p>分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select user_id,user_name from order</span><br><span class="line">where user_id &lt;= 200</span><br><span class="line">group by user_id</span><br></pre></td></tr></table></figure>

<p>使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。</p>
<blockquote>
<p>其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。</p>
</blockquote>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySql/Sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/" data-id="clktuzzgq0049cdooa4yb7ugv" data-title="Sql语句优化的小技巧" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis唯快不破的秘密" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%E7%9A%84%E7%A7%98%E5%AF%86/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%E7%9A%84%E7%A7%98%E5%AF%86/">Redis唯快不破的秘密</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根据官方数据，Redis 的 QPS 可以达到约 100000（每秒请求数），有兴趣的可以参考官方的基准程序测试《How fast is Redis？》，地址：<a target="_blank" rel="noopener" href="https://redis.io/topics/benchmarks">https://redis.io/topics/benchmarks</a></p>
<h2 id="完全基于内存实现"><a href="#完全基于内存实现" class="headerlink" title="完全基于内存实现"></a>完全基于内存实现</h2><p>内存直接由 CPU 控制，也就是 CPU 内部集成的内存控制器，所以说内存是直接与 CPU 对接，享受与 CPU 通信的最优带宽。<strong>Redis 将数据存储在内存中，读写操作不会因为磁盘的 IO 速度限制</strong>。</p>
<h2 id="高效的数据结构"><a href="#高效的数据结构" class="headerlink" title="高效的数据结构"></a>高效的数据结构</h2><p>MySQL 为了提高检索速度使用了 B+ Tree 数据结构，所以 Redis 速度快应该也跟数据结构有关。Redis 提供给我们使用的 5 种数据类型：String、List、Hash、Set、SortedSet。</p>
<p>在 Redis 中，常用的 5 种数据类型和应用场景如下：</p>
<ul>
<li><strong>String：</strong> 缓存、计数器、分布式锁等。</li>
<li><strong>List：</strong> 链表、队列、微博关注人时间轴列表等。</li>
<li><strong>Hash：</strong> 用户信息、Hash 表等。</li>
<li><strong>Set：</strong> 去重、赞、踩、共同好友等。</li>
<li><strong>Zset：</strong> 访问量排行榜、点击量排行榜等。</li>
</ul>
<p>当然是为了追求速度，不同数据类型使用不同的数据结构速度才得以提升。每种数据类型都有一种或者多种数据结构来支撑，底层数据结构有 6 种。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="Redis数据类型与底层数据结构关系"></p>
<h3 id="Redis-hash-字典"><a href="#Redis-hash-字典" class="headerlink" title="Redis hash 字典"></a>Redis hash 字典</h3><p>Redis 整体就是一个哈希表来保存所有的键值对，无论数据类型是 5 种的任意一种。哈希表，本质就是一个数组，每个元素被叫做哈希桶，不管什么数据类型，每个桶里面的 entry 保存着实际具体值的指针。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/Redis%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="Redis全局哈希表"></p>
<p>整个数据库就是一个<strong>全局哈希表</strong>，而哈希表的时间复杂度是 O(1)，只需要计算每个键的哈希值，便知道对应的哈希桶位置，定位桶里面的 entry 找到对应数据，这个也是 Redis 快的原因之一。</p>
<p>随着写入 Redis 的数据越来越多的时候，哈希冲突不可避免，会出现不同的 key 计算出一样的哈希值。</p>
<p>Redis 通过<strong>链式哈希</strong>解决冲突：<strong>也就是同一个 桶里面的元素使用链表保存</strong>。但是当链表过长就会导致查找性能变差可能，所以 Redis 为了追求快，使用了两个全局哈希表。用于 rehash 操作，增加现有的哈希桶数量，减少哈希冲突。</p>
<p>开始默认使用 hash 表 1 保存键值对数据，哈希表 2 此刻没有分配空间。当数据越来多触发 rehash 操作，则执行以下操作：</p>
<ol>
<li>给 hash 表 2 分配更大的空间；</li>
<li>将 hash 表 1 的数据重新映射拷贝到 hash 表 2 中；</li>
<li>释放 hash 表 1 的空间。</li>
</ol>
<p><strong>值得注意的是，将 hash 表 1 的数据重新映射到 hash 表 2 的过程中并不是一次性的，这样会造成 Redis 阻塞，无法提供服务。</strong></p>
<p>而是采用了<strong>渐进式 rehash</strong>，每次处理客户端请求的时候，先从 hash 表 1 中第一个索引开始，将这个位置的 所有数据拷贝到 hash 表 2 中，就这样将 rehash 分散到多次请求过程中，避免耗时阻塞。</p>
<h3 id="SDS-简单动态字符"><a href="#SDS-简单动态字符" class="headerlink" title="SDS 简单动态字符"></a>SDS 简单动态字符</h3><p>字符串结构使用最广泛，<strong>通常我们用于缓存登陆后的用户信息</strong>，key &#x3D; userId，value &#x3D; 用户信息 JSON 序列化成字符串。</p>
<p>C 语言中字符串的获取 「MageByte」的长度，要从头开始遍历，直到 「\0」为止，对于redis来说，这样是不能容忍的。</p>
<p>C 语言字符串结构与 SDS 字符串结构对比图如下所示：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/C%20%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8ESDS.png" alt="C 语言字符串与SDS"></p>
<p>两者的区别：</p>
<ol>
<li>SDS有着<strong>O(1) 时间复杂度获取字符串长度</strong></li>
<li><strong>空间预分配</strong>：SDS 被修改后，程序不仅会为 SDS 分配所需要的必须空间，还会分配额外的未使用空间。分配规则如下：如果对 SDS 修改后，len 的长度小于 1M，那么程序将分配和 len 相同长度的未使用空间。如果对 SDS 修改后 len 长度大于 1M，那么程序将分配 1M 的未使用空间。</li>
<li><strong>惰性空间释放</strong>：当对 SDS 进行缩短操作时，程序并不会回收多余的内存空间，而是使用 free 字段将这些字节数量记录下来不释放，后面如果需要 append 操作，则直接使用 free 中未使用的空间，减少了内存的分配。</li>
<li><strong>二进制安全</strong>：在 Redis 中不仅可以存储 String 类型的数据，也可能存储一些二进制数据。二进制数据并不是规则的字符串格式，其中会包含一些特殊的字符如 ‘\0’，在 C 中遇到 ‘\0’ 则表示字符串的结束，但在 SDS 中，标志字符串结束的是 len 属性。</li>
</ol>
<h3 id="zipList-压缩列表"><a href="#zipList-压缩列表" class="headerlink" title="zipList 压缩列表"></a>zipList 压缩列表</h3><p>当一个列表只有少量数据的时候，那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<p>ziplist 是由一系列特殊编码的连续内存块组成的顺序型的数据结构，ziplist 中可以包含多个 entry 节点，每个节点可以存放整数或者字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    int32 zlbytes; <span class="comment">// 整个压缩列表占用字节数</span></span><br><span class="line">    int32 zltail_offset; <span class="comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</span></span><br><span class="line">    int16 zllength; <span class="comment">// 元素个数</span></span><br><span class="line">    T[] entries; <span class="comment">// 元素内容列表，挨个挨个紧凑存储</span></span><br><span class="line">    int8 zlend; <span class="comment">// 标志压缩列表的结束，值恒为 0xFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E7%9A%84ziplist.png" alt="redis的ziplist"></p>
<p>如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N)</p>
<h3 id="linkedlis双端列表"><a href="#linkedlis双端列表" class="headerlink" title="linkedlis双端列表"></a>linkedlis双端列表</h3><p>Redis List 数据类型通常被用于队列、微博关注人时间轴列表等场景。不管是先进先出的队列，还是先进后出的栈，双端列表都很好的支持这些特性。</p>
<p>后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。</p>
<p><strong>quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。</strong></p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E7%9A%84quicklist.png" alt="redis的quicklist"></p>
<h3 id="skipList-跳跃表"><a href="#skipList-跳跃表" class="headerlink" title="skipList 跳跃表"></a>skipList 跳跃表</h3><p>sorted set 类型的排序功能便是通过「跳跃列表」数据结构来实现。</p>
<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到<em>快速访问节点</em>的目的。</p>
<p>跳跃表支持平均 O（logN）、最坏 O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>跳表在链表的基础上，增加了多层级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%E8%B7%B3%E8%B7%83%E8%A1%A8.png" alt="跳跃表"></p>
<p>当需要查找 40 这个元素需要经历三次查找。</p>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p><strong>我们要明确的是：Redis 的单线程指的是 Redis 的网络 IO 以及键值对指令读写是由一个线程来执行的。</strong> 对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行。</p>
<p>在运行每个任务之前，CPU 需要知道任务在何处加载并开始运行。也就是说，系统需要帮助它预先设置 CPU 寄存器和程序计数器，这称为 CPU 上下文。</p>
<p>这些保存的上下文存储在系统内核中，并在重新计划任务时再次加载。这样，任务的原始状态将不会受到影响，并且该任务将看起来正在连续运行。</p>
<p><strong>切换上下文时，我们需要完成一系列工作，这是非常消耗资源的操作。</strong></p>
<h3 id="单线程又什么好处？"><a href="#单线程又什么好处？" class="headerlink" title="单线程又什么好处？"></a>单线程又什么好处？</h3><ol>
<li>不会因为线程创建导致的性能消耗；</li>
<li>避免上下文切换引起的 CPU 消耗，没有多线程切换的开销；</li>
<li>避免了线程之间的竞争问题，比如添加锁、释放锁、死锁等，不需要考虑各种锁问题。</li>
<li>代码更清晰，处理逻辑简单。</li>
</ol>
<p>因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最<strong>有可能是机器内存的大小或者网络带宽</strong>。</p>
<h2 id="I-O-多路复用模型"><a href="#I-O-多路复用模型" class="headerlink" title="I&#x2F;O 多路复用模型"></a>I&#x2F;O 多路复用模型</h2><p>Redis 采用 I&#x2F;O 多路复用技术，并发处理连接。采用了 epoll + 自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 IO 上浪费一点时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%E7%9A%84%E7%A7%98%E5%AF%86/" data-id="clktuzzgr004dcdooa2nv9s6s" data-title="Redis唯快不破的秘密" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Redis常见数据类型与命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h2><ol>
<li><p>查看键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure>

<p>支持模糊匹配，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys novel_to_novel_*_pahina</span><br><span class="line">查询结果：</span><br><span class="line">1) &quot;novel_to_novel_doc_pahina&quot;</span><br><span class="line">2) &quot;novel_to_novel_gatne_pahina&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>键总数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>

<p>dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所以dbsize命令的时间复杂度是O（1）。而keys 命令会遍历所有键，所以它的时间复杂度是O（n）。</p>
</li>
<li><p>检查键是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure>

<p>如果键存在则返回1，不存在则返回0。</p>
</li>
<li><p>删除键</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key [key ...]</span><br></pre></td></tr></table></figure>

<p>返回结果为成功删除键的个数，假设删除一个不存在的键，就会返回0。</p>
</li>
<li><p>键过期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br></pre></td></tr></table></figure>

<p>单位秒。ttl命令会返回键的剩余过期时间，它有3种返回值：</p>
<ul>
<li>大于等于0的整数：键剩余的过期时间。</li>
<li>-1：键没设置过期时间。</li>
<li>-2：键不存在。</li>
</ul>
<p>可以通过ttl命令观察键hello的剩余过期时间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure>
</li>
<li><p>键的数据结构类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure>
</li>
<li><p>渐进式遍历</p>
<p>当数据量很庞大的时候，使用如：keys *、smembers、hgetall、zrange，可能产生的阻塞问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor [match pattern] [count number]</span><br></pre></td></tr></table></figure>

<ul>
<li>cursor是必需参数，实际上cursor是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，<strong>直到游标值为0，表示遍历结束</strong>。</li>
<li>match pattern是可选参数，它的作用的是做模式的匹配，这点和keys的模式匹配很像。</li>
<li>count number是可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。</li>
</ul>
<p>另外hgetall、smembers、zrange对应渐进式遍历的命令分别是hscan、sscan、zscan。</p>
</li>
</ol>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如 JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ol>
<li><p>设置值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br></pre></td></tr></table></figure>

<p>set命令有几个选项：</p>
<ul>
<li>ex seconds：为键设置秒级过期时间。如设置过期时间50秒：set key value ex 50</li>
<li>px milliseconds：为键设置毫秒级过期时间。如设置过期时间50毫秒：set key value px 50</li>
<li>nx：键必须不存在，才可以设置成功，用于添加。如：set key value nx 50</li>
<li>xx：与nx相反，键必须存在，才可以设置成功，用于更新。</li>
</ul>
<p>除了set选项，Redis还提供了setex和setnx两个命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">setnx key value</span><br></pre></td></tr></table></figure>

<p>setex在逻辑上等价于set和expire合并的操作或者等价于set+ex参数，设置一个值并且添加过期时间；</p>
<p>setnx在逻辑上等价于set+nx参数。</p>
<p><strong>setex和setex属于原子操作，只发送一次命令，所有只有一次网络时间。</strong></p>
</li>
<li><p>获取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key		//键不存在，则返回空（nil）</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量设置值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量获取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key ...]</span><br></pre></td></tr></table></figure>

<p>批量操作命令可以有效提高开发效率，如果使用get命令批量获取n个值，则需要耗时：<u>n次get时间 &#x3D; n次网络时间 + n次命令时间</u>，模型如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%20n%E6%AC%A1get%E7%9A%84%E6%A8%A1%E5%9E%8B.png" alt="redis n次get的模型"></p>
<p>使用mget命令后，需要耗时：<u>n次get时间 &#x3D; 1次网络时间 + n次命令时间</u>，模型如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%20%E4%B8%80%E6%AC%A1mget%E7%9A%84%E6%A8%A1%E5%9E%8B.png" alt="redis 一次mget的模型"></p>
</li>
<li><p>计数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure>

<p>incr命令用于对值做自增操作，返回结果分为三种情况：</p>
<ul>
<li>值不是整数，返回错误。</li>
<li>值是整数，返回自增后的结果。</li>
<li>键不存在，按照值为0自增，返回结果为1。</li>
</ul>
</li>
</ol>
<p>字符串类型命令时间复杂度如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="redis字符串类型命令时间复杂度"></p>
<h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>字符串类型的内部编码有3种：</p>
<ul>
<li><p>int：8个字节的长整型。</p>
</li>
<li><p>embstr：小于等于39个字节的字符串。</p>
</li>
<li><p>raw：大于39个字节的字符串。</p>
</li>
</ul>
<p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>在Redis中，哈希类型是指键值本身又是一个键值对结构，形如<code>value=&#123;&#123;field1，value1&#125;，...&#123;fieldN， valueN&#125;&#125;</code>，Redis键值对和哈希类型二者的关系如下图：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%E5%85%B3%E7%B3%BB.png" alt="redis哈希类型关系"></p>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ol>
<li><p>设置值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key field value</span><br></pre></td></tr></table></figure>

<p>如果设置成功会返回1，反之会返回0。此外Redis提供了hsetnx命令，它们的关系就像set和setnx命令一样，只不过作用域由键变为field。</p>
</li>
<li><p>获取值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget key field //如果键或field不存在，会返回nil</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除field</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdel key field [field ...]</span><br></pre></td></tr></table></figure>

<p>hdel会删除一个或多个field，返回结果为成功删除field的个数。</p>
</li>
<li><p>计算field个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量设置或获取field-value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field ...]</span><br><span class="line">hmset key field value [field value ...]</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有field</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals key</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有的field-value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall key</span><br></pre></td></tr></table></figure>

<p><strong>在使用hgetall时，如果哈希元素个数比较多，会存在阻塞Redis 的可能。如果开发人员只需要获取部分field，可以使用hmget，如果一定要获取全部field-value，可以使用hscan命令，该命令会渐进式遍历哈希类型。</strong></p>
</li>
</ol>
<p>哈希类型命令的时间复杂度如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="redis哈希类型命令的时间复杂度"></p>
<h3 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h3><ul>
<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于hash-maxziplist-value配置（默认64字节）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</li>
<li>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时， Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O（1）。</li>
</ul>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）类型是用来存储多个<strong>有序</strong>的字符串，一个列表最多可以存储2^32-1个元素,在Redis中，可以对列表两端插入（push）和弹出（pop）</p>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ol>
<li><p>添加操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpush key value [value ...]		//右边插入元素</span><br><span class="line">lpush key value [value ...]		//左边插入元素</span><br><span class="line">linsert key before|after pivot value	//向某个元素前或者后插入元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end	</span><br><span class="line">//获取指定范围内的元素列表，索引下标有两个特点：第一，索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N。第二，lrange中的end选项包含了自身。</span><br><span class="line"></span><br><span class="line">lindex key index	//获取列表指定索引下标的元素</span><br><span class="line">llen key	//获取列表长度</span><br></pre></td></tr></table></figure>

<p><strong>lrange属于比较重的命令，如果元素过多 存在阻塞Redis的可能性，这时候可以使用sscan来完成。</strong></p>
</li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lpop key	//从列表左侧弹出元素</span><br><span class="line">rpop key	//从列表右侧弹出元素</span><br><span class="line">lrem key count value	//删除指定元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue	//修改指定索引下标的元素</span><br></pre></td></tr></table></figure></li>
</ol>
<p>哈希类型命令的时间复杂度如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%E5%88%97%E8%A1%A8%E5%91%BD%E4%BB%A4%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="列表命令时间复杂度"></p>
<h3 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h3><ul>
<li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的 内部实现来减少内存的使用。</li>
<li>linkedlist（链表）：当列表类型无法满足ziplist的条件时， Redis会使用linkedlist作为列表的内部实现。</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，<strong>集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素</strong>。一个集合最多可以存储2^32-1个元素。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E4%B8%ADset%E7%9A%84%E6%A8%A1%E5%9E%8B.png" alt="redis中set的模型"></p>
<h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ol>
<li><p>集合内操作</p>
<p>（1）添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key element [element ...]</span><br></pre></td></tr></table></figure>

<p>（2）删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srem key element [element ...]</span><br></pre></td></tr></table></figure>

<p>（3）计算元素个数</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scard key</span><br></pre></td></tr></table></figure>

<p>（4）判断元素是否在集合中</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key element</span><br></pre></td></tr></table></figure>

<p>（5）随机从集合返回指定个数元素</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srandmember key [count]</span><br></pre></td></tr></table></figure>

<p>（6）从集合随机弹出元素</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spop key</span><br></pre></td></tr></table></figure>

<p>（7）获取所有元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure>

<p><strong>smembers，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</strong></p>
</li>
<li><p>集合间操作</p>
<p>（1）求多个集合的交集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key ...]</span><br></pre></td></tr></table></figure>

<p>（2）求多个集合的并集</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">suinon key [key ...]</span><br></pre></td></tr></table></figure>

<p>（3）求多个集合的差集</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdiff key [key ...]</span><br></pre></td></tr></table></figure>

<p>（4）将交集、并集、差集的结果保存</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinterstore destination key [key ...]</span><br><span class="line">suionstore destination key [key ...]</span><br><span class="line">sdiffstore destination key [key ...]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>哈希类型命令的时间复杂度如下：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E4%B8%ADset%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="redis中set常用命令时间复杂度"></p>
<h3 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h3><ul>
<li>intset（整数集合）：当集合中的元素都是整数且元素个数小 于set-max-intset-entries配置（默认512个）时，Redis会选用 intset来作为集合的内部实现，从而减少内存的使用。</li>
<li>hashtable（哈希表）：当集合类型无法满足intset的条件时， Redis会使用hashtable作为集合的内部实现。</li>
</ul>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><h3 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h3><ol>
<li><p>集合内操作</p>
<p>（1）添加元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member [score member ...]</span><br></pre></td></tr></table></figure>

<p>Redis3.2为zadd命令添加了nx、xx、ch、incr四个选项：</p>
<ul>
<li><p>nx：member必须不存在，才可以设置成功，用于添加。</p>
</li>
<li><p>xx：member必须存在，才可以设置成功，用于更新。</p>
</li>
<li><p>ch：返回此次操作后，有序集合元素和分数发生变化的个数</p>
</li>
<li><p>incr：对score做增加，相当于后面介绍的zincrby。</p>
</li>
</ul>
<p>有序集合相比集合提供了排序字段，但是也产生了代价，zadd的时 间复杂度为O（log（n）），sadd的时间复杂度为O（1）。</p>
<p>（2）计算成员个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcard key</span><br></pre></td></tr></table></figure>

<p>（3）计算某个成员的分数</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zscore key member</span><br></pre></td></tr></table></figure>

<p>（4）计算成员的排名</p>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br></pre></td></tr></table></figure>

<p>zrank是从分数从低到高返回排名，zrevrank反之</p>
<p>（5）删除成员</p>
<pre><code>  ```
  zrem key member [member ...]
</code></pre>
</li>
</ol>
<h3 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h3><ul>
<li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的 内部实现来减少内存的使用。</li>
<li>linkedlist（双端链表）：当列表类型无法满足ziplist的条件时， Redis会使用linkedlist作为列表的内部实现。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="clktuzzgs004ecdooav9b1ln6" data-title="Redis常见数据类型与命令" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis性能优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">Redis性能优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 是基于单线程模型实现的，也就是 Redis 使用一个线程来处理所有的客户端请求，尽管 Redis 使用了非阻塞式 IO，并且对各种命令都做了优化（大部分命令操作时间复杂度都是 O(1)），但由于 Redis 是单线程执行的特点，因此它对性能的要求更加苛刻，本文我们将通过一些优化手段，让 Redis 更加高效的运行。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="缩短键值对的存储长度"><a href="#缩短键值对的存储长度" class="headerlink" title="缩短键值对的存储长度"></a>缩短键值对的存储长度</h3><p>在 key 不变的情况下，value 值越大操作效率越慢，因为 Redis 对于同一种数据类型会使用不同的内部编码进行存储，通过不同编码实现效率和空间的平衡，然而数据量越大使用的内部编码就越复杂，而越是复杂的内部编码存储的性能就越低。</p>
<p>因此在保证完整语义的同时，我们要尽量的缩短键值对的存储长度，必要时要对数据进行<strong>序列化</strong>和<strong>压缩</strong>再存储。</p>
<h3 id="使用-lazy-free-特性"><a href="#使用-lazy-free-特性" class="headerlink" title="使用 lazy free 特性"></a>使用 lazy free 特性</h3><p>lazy free 特性是 Redis 4.0 新增的一个非常使用的功能，它可以理解为惰性删除或延迟删除。意思是<strong>在删除的时候提供异步延时释放键值的功能</strong>，把键值释放操作放在 BIO(Background I&#x2F;O) 单独的子线程处理中，以减少删除删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。</p>
<p>lazy free 对应了 4 种场景，默认都是关闭的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">slave-lazy-flush no</span><br></pre></td></tr></table></figure>

<p>它们代表的含义如下：</p>
<ul>
<li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li>slave-lazy-flush：针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<h3 id="设置键值的过期时间"><a href="#设置键值的过期时间" class="headerlink" title="设置键值的过期时间"></a>设置键值的过期时间</h3><p>我们应该根据实际的业务情况，对键值设置合理的过期时间，这样 Redis 会帮你自动清除过期的键值对，以节约对内存的占用，以避免键值过多的堆积，频繁的触发内存淘汰策略。</p>
<h3 id="禁用长耗时的查询命令"><a href="#禁用长耗时的查询命令" class="headerlink" title="禁用长耗时的查询命令"></a>禁用长耗时的查询命令</h3><p>要避免 O(N) 命令对 Redis 造成的影响，可以从以下几个方面入手改造：</p>
<ul>
<li>禁止使用 keys 命令；</li>
<li>避免一次查询所有的成员，要使用 scan 命令进行分批的，游标式的遍历；</li>
<li>通过机制严格控制 Hash、Set、Sorted Set 等结构的数据大小；</li>
<li>将排序、并集、交集等操作放在客户端执行，以减少 Redis 服务器运行压力；</li>
<li>删除 (del) 一个大数据的时候，可能会需要很长时间，所以建议用异步删除的方式 unlink，它会启动一个新的线程来删除目标数据，而不阻塞 Redis 的主线程。</li>
</ul>
<h3 id="使用-slowlog-优化耗时命令"><a href="#使用-slowlog-优化耗时命令" class="headerlink" title="使用 slowlog 优化耗时命令"></a>使用 slowlog 优化耗时命令</h3><p>可以使用 slowlog 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度，慢查询有两个重要的配置项：</p>
<ul>
<li><code>slowlog-log-slower-than</code> ：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)；</li>
<li><code>slowlog-max-len</code> ：用来配置慢查询日志的最大记录数。</li>
</ul>
<p>我们可以根据实际的业务情况进行相应的配置，其中慢日志是按照插入的顺序倒序存入慢查询日志中，我们可以使用 <code>slowlog get n</code> 来获取相关的慢查询日志，再找到这些慢查询对应的业务进行相关的优化。</p>
<h3 id="使用-Pipeline-批量操作数据"><a href="#使用-Pipeline-批量操作数据" class="headerlink" title="使用 Pipeline 批量操作数据"></a>使用 Pipeline 批量操作数据</h3><p>Pipeline (管道技术) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<h3 id="避免大量数据同时失效"><a href="#避免大量数据同时失效" class="headerlink" title="避免大量数据同时失效"></a>避免大量数据同时失效</h3><p>Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 <code>hz 10</code>，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25% ，重复执行此流程，如下图所示：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%88%A0%E9%99%A4%E8%BF%87%E6%9C%9F%E9%94%AE%E6%B5%81%E7%A8%8B.png" alt="redis删除过期键流程"></p>
<p>如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。</p>
<p>为了避免这种卡顿现象的产生，我们需要预防大量的缓存在同一时刻一起过期，就简单的解决方案就是<strong>在过期时间的基础上添加一个指定范围的随机数</strong>。</p>
<h3 id="客户端使用优化"><a href="#客户端使用优化" class="headerlink" title="客户端使用优化"></a>客户端使用优化</h3><p>在客户端的使用上我们除了要尽量使用 Pipeline 的技术外，还需要注意要尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。</p>
<h3 id="限制-Redis-内存大小"><a href="#限制-Redis-内存大小" class="headerlink" title="限制 Redis 内存大小"></a>限制 Redis 内存大小</h3><p>在 64 位操作系统中 Redis 的内存大小是没有限制的，也就是配置项 <code>maxmemory &lt;bytes&gt;</code> 是被注释掉的，这样就会导致在物理内存不足时，使用 swap 空间既交换空间，而当操心系统将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现延迟，从而影响 Redis 的整体性能。因此我们需要限制 Redis 的内存大小为一个固定的值，当 Redis 的运行到达此值时会触发内存淘汰策略，<strong>内存淘汰策略在 Redis 4.0 之后有 8 种</strong>：</p>
<ol>
<li><strong>noeviction</strong>：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li>
<li><strong>allkeys-lru</strong>：淘汰整个键值中最久未使用的键值；</li>
<li><strong>allkeys-random</strong>：随机淘汰任意键值;</li>
<li><strong>volatile-lru</strong>：淘汰所有设置了过期时间的键值中最久未使用的键值；</li>
<li><strong>volatile-random</strong>：随机淘汰设置了过期时间的任意键值；</li>
<li><strong>volatile-ttl</strong>：优先淘汰更早过期的键值。</li>
</ol>
<p>在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p>
<ol>
<li><strong>volatile-lfu</strong>：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
<li><strong>allkeys-lfu</strong>：淘汰整个键值中最少使用的键值。</li>
</ol>
<p>其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p>
<p>我们可以根据实际的业务情况进行设置，默认的淘汰策略不淘汰任何数据，在新增时会报错。</p>
<h3 id="使用分布式架构来增加读写速度"><a href="#使用分布式架构来增加读写速度" class="headerlink" title="使用分布式架构来增加读写速度"></a>使用分布式架构来增加读写速度</h3><p>Redis 分布式架构有三个重要的手段：</p>
<ol>
<li><p>主从同步</p>
<p>使用主从同步功能我们可以把写入放到主库上执行，把读功能转移到从服务上，因此就可以在单位时间内处理更多的请求，从而提升的 Redis 整体的运行速度。</p>
</li>
<li><p>哨兵模式</p>
<p>哨兵模式是对于主从功能的升级，但当主节点奔溃之后，无需人工干预就能自动恢复 Redis 的正常使用。</p>
</li>
<li><p>Redis Cluster 集群</p>
<p>Redis Cluster 是 Redis 3.0 正式推出的，Redis 集群是通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot &#x3D; CRC16(key) &amp; 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。</p>
</li>
</ol>
<p>在这三个功能中，我们只需要使用一个就行了，毫无疑问 <strong>Redis Cluster 应该是首选的实现方案</strong>，它可以把读写压力自动的分担给更多的服务器，并且拥有自动容灾的能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" data-id="clktuzzgw004hcdoobjx08y0g" data-title="Redis性能优化" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis缓存设计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/">Redis缓存设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis作为缓存使用，不仅能加速读写速度，还能降低后端负载。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/redis%E7%BC%93%E5%AD%98.png" alt="redis缓存"></p>
<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>缓存中的数据会和数据源中的真实数据有一段时间窗口的不一致，需要利用某些策略进行更新。下面将分别从使用场景、一致性、开发人员开发&#x2F;维护成本三个方面介绍三种缓存的更新策略。</p>
<ol>
<li><p>LRU&#x2F;LFU&#x2F;FIFO算法剔除<br>剔除算法通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。但是要清理哪些数据是由具体算法决定。</p>
</li>
<li><p>超时剔除</p>
<p>超时剔除通过给缓存数据设置过期时间，让其在过期 时间后自动删除，例如Redis提供的expire命令。如果业务可以容忍一段时间内，缓存层数据和存储层数据不一致，那么可以为其设置过期 时间。</p>
</li>
<li><p>主动更新</p>
<p>应用方对于数据的一致性要求高，需要在真实数据更新后，立即更新缓存数据。例如可以利用消息系统或者其他方式通知缓存更新。</p>
</li>
</ol>
<p>三种缓存更新策略对比如下：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">一致性</th>
<th align="center">维护成本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LRU&#x2F;LFU&#x2F;FIFO算法剔除</td>
<td align="center">最差</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">超时剔除</td>
<td align="center">较差</td>
<td align="center">较低</td>
</tr>
<tr>
<td align="center">主动更新</td>
<td align="center">强</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h2 id="缓存读写策略"><a href="#缓存读写策略" class="headerlink" title="缓存读写策略"></a>缓存读写策略</h2><p>以标准的“缓存 + 数据库”的场景为例，剖析经典的缓存读写策略以及它们适用的场景。在日常的工作中根据不同的场景选择不同的读写策略。</p>
<h3 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h3><p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt="旁路缓存策略"></p>
<p>这个策略数据<strong>以数据库中的数据为准</strong>，缓存中的数据是按需加载的。它可以分为读策略和写策略，其中读策略的步骤是： </p>
<ul>
<li>从缓存中读取数据；</li>
<li>如果缓存命中，则直接返回数据；</li>
<li>如果缓存不命中，则从数据库中查询数据；</li>
<li>查询到数据后，将数据写入到缓存中，并且返回给用户。</li>
</ul>
<p>写策略的步骤是：</p>
<ul>
<li>更新数据库中的记录； </li>
<li>删除缓存记录。</li>
</ul>
<p>Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p>
<ol>
<li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li>
<li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。</li>
</ol>
<h3 id="Read-Write-Through（读穿-写穿）策略"><a href="#Read-Write-Through（读穿-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h3><p>这个策略的核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。</p>
<p>（1）Write Through 的策略是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。</p>
<p>一般来说，我们可以选择两种“Write Miss”方式：一个是“Write Allocate（按写分 配）”，做法是写入缓存相应位置，再由缓存组件同步更新到数据库中；另一个是“Nowrite allocate（不按写分配）”，做法是不写入缓存中，而是直接更新到数据库中。</p>
<p>在 Write Through 策略中，我们一般选择“No-write allocate”方式，原因是无论采用哪 种“Write Miss”方式，我们都需要同步将数据更新到数据库中，而“No-write allocate”方式相比“Write Allocate”还减少了一次缓存的写入，能够提升写入的性能。</p>
<p>（2）Read Through 策略就简单一些，它的步骤是这样的：先查询缓存中数据是否存在，如果 存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/Read%E5%92%8CWrite%20Through%E7%AD%96%E7%95%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Read和Write Through策略示意图"></p>
<h3 id="Write-Back（写回）策略"><a href="#Write-Back（写回）策略" class="headerlink" title="Write Back（写回）策略"></a>Write Back（写回）策略</h3><p>这个策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块只有被再次使用时才会将其中的数据写入到后端存储中。</p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/write%20back%E5%86%99%E7%AD%96%E7%95%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="write back写策略示意图"></p>
<p><img src="https://raw.githubusercontent.com/OverCookkk/PicBed/master/blogImg/write%20back%E8%AF%BB%E7%AD%96%E7%95%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="write back读策略示意图"></p>
<h2 id="缓存穿透优化"><a href="#缓存穿透优化" class="headerlink" title="缓存穿透优化"></a>缓存穿透优化</h2><h3 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h3><p>缓存穿透指的是当用户查询数据，在缓存中不存在，并且在数据库也不存在时，导致用户查询这样的数据(或者恶意攻击) 在缓存中找不到对应key的value，每次都需要在数据库中查询一遍，然后返回空值。</p>
<p>其实这就相当于进行了两次无用的查询，这样请求就绕过缓存直接查数据库，对数据库造成了很大的压力。</p>
<h3 id="如何防止缓存穿透"><a href="#如何防止缓存穿透" class="headerlink" title="如何防止缓存穿透"></a>如何防止缓存穿透</h3><ol>
<li><p><strong>缓存空值</strong></p>
<p>如果DB查询返回数据或者业务结果为空，此时我们仍然将空结果进行缓存，由于空值做了缓存，占用更多的内存空间，所以需要对这些数据设置一个<strong>较短</strong>的过期时间(不超过五分钟)。</p>
<p>缺点：但如果有大量请求穿透到数据库，然后回写缓存空值，缓存内存有大量的空值缓存，也就会浪费缓存的存储空间，如果缓存空间被占满了，还会剔除掉一些已经被缓存的信息，反而会造成缓存命中率的下降。 所以这个方案，在使用的时候应该评估一下缓存容量是否能够支撑。</p>
</li>
<li><p><strong>布隆过滤器拦截</strong></p>
<p>在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截，从而避免了对底层存储系统的查询压力。（即位图形式，每一个经过hash后存在bit位中，bit位是1代表存在，0代表不存在）</p>
<p>缺点：</p>
</li>
</ol>
<p>tips:GitHub上已经开源了类似的方案，可以进行参考：<a target="_blank" rel="noopener" href="https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter%E3%80%82">https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter。</a></p>
<p>两种方案对比如下：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>适用场景</th>
<th>维护成本</th>
</tr>
</thead>
<tbody><tr>
<td>缓存空对象</td>
<td>数据命中不高、数据频繁变化实时性高</td>
<td>需要过多的缓存空间并且数据不一致</td>
</tr>
<tr>
<td>布隆过滤器</td>
<td>数据命中不高、数据相对固定实时性低</td>
<td>缓存空间占用小</td>
</tr>
</tbody></table>
<h2 id="缓存雪崩优化"><a href="#缓存雪崩优化" class="headerlink" title="缓存雪崩优化"></a>缓存雪崩优化</h2><h3 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h3><p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有查询都落在数据库上，就会造成了缓存雪崩。由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都需要去查询数据库，从而对数据库服务CPU和内存造成巨大压力，严重可能会造成数据库服务宕机。</p>
<h3 id="如何防止缓存雪崩"><a href="#如何防止缓存雪崩" class="headerlink" title="如何防止缓存雪崩"></a>如何防止缓存雪崩</h3><ol>
<li><p><strong>过期时间 + 随机值</strong></p>
<p>要避免给大量的数据设置一样的过期时间，过期时间 &#x3D; baes 时间+ 随机时间（较小的随机数，比如随机增加 1~5 分钟）。</p>
<p>这样一来，就不会导致同一时刻热点数据全部失效，同时过期时间差别也不会太大，既保证了相近时间失效，又能满足业务需求。</p>
</li>
<li><p><strong>加锁排队</strong></p>
<p>维护一个mutex互斥锁，通过Redis的SETNX命令去设置一把当前业务操作的锁(例如setnx lock_uid_001 value nullValue、setnx lock_white_list value nullValue)，只允许一个线程查询数据和写缓存，其他线程如果发现有锁就等待，等解锁后再返回数据。该方案会造成部分请求等待。</p>
</li>
<li><p><strong>双层缓存策略</strong></p>
<p>同一条数据我们可以维护两套缓存，C1为原始缓存，C2为拷贝缓存，当C1失效时，可以读取C2，都不存在时再去访问数据库回设，当然C1缓存失效时间需要设置为短期（如5min），而C2设置为长期（如1天）。这种方式最大缺点就是占用的内存翻倍。</p>
</li>
<li><p><strong>双key</strong></p>
<p>思路和方案2类似，不同的是双key分别缓存过期时间（key-time)和缓存数据（key-data），其中(key-time)的缓存失效时间设置为短期（比如5min），(key-data)的缓存失效时间设置为长期（比如1天）。当第一个线程发现 key-time 过期不存在时，则先更新key-time，然后去查询数据库并更新key-data 的值；当其他线程来获取数据时，虽然第一个线程还没有从数据库查询完毕并更新缓存，但发现key-time存在，会直接读取缓存的旧数据返回。和二级缓存的方案对比，该方案的缓存空间利用率高。</p>
</li>
</ol>
<h2 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h2><h3 id="什么是热点key？"><a href="#什么是热点key？" class="headerlink" title="什么是热点key？"></a>什么是热点key？</h3><p>某个key访问非常频繁，当key失效的时候有大量线程来访问数据库然后再写到缓存，导致负载增加，系统崩溃。</p>
<h3 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h3><p>减少热点key的重建次数</p>
<ol>
<li><p><strong>互斥锁（mutex key)</strong></p>
<p>此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。（使用setnx命令实现上述功能）</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8D%E5%BB%BA%E7%BC%93%E5%AD%98.png" alt="使用互斥重建缓存"></p>
</li>
<li><p><strong>缓存过期时间不设置</strong></p>
<p>缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/" data-id="clktuzzgy004kcdoochbs8l5b" data-title="Redis缓存设计" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis高可用篇：Cluster 集群原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9ACluster%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9ACluster%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/">Redis高可用篇：Cluster 集群原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="为什么需要Cluster"><a href="#为什么需要Cluster" class="headerlink" title="为什么需要Cluster"></a>为什么需要Cluster</h2><p>保存大量数据，除了使用大内存主机的方式，我们还可以使用切片集群。俗话说「众人拾材火焰高」，一台机器无法保存所有数据，那就多台分担。</p>
<p><strong>使用 Redis Cluster 集群，主要解决了大数据量存储导致的各种慢问题，同时也便于横向拓展。</strong></p>
<p>两种方案对应着 Redis 数据增多的两种拓展方案：<strong>垂直扩展（scale up）、水平扩展（scale out）。</strong></p>
<ol>
<li>垂直拓展：升级单个 Redis 的硬件配置，比如增加内存容量、磁盘容量、使用更强大的 CPU。</li>
<li>水平拓展：横向增加 Redis 实例个数，每个节点负责一部分数据。</li>
</ol>
<h2 id="什么是Cluster集群"><a href="#什么是Cluster集群" class="headerlink" title="什么是Cluster集群"></a>什么是Cluster集群</h2><p>Redis 集群是一种分布式数据库方案，集群通过分片（sharding）来进行数据管理（「分治思想」的一种实践），并提供复制和故障转移功能。</p>
<p>将数据划分为 16384 的 slots，每个节点负责一部分槽位。槽位的信息存储于每个节点中。</p>
<p>它是去中心化的，如图所示，该集群有三个 Redis 节点组成，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/Redis%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.jpg" alt="Redis集群架构"></p>
<p>三个节点相互连接组成一个对等的集群，它们之间通过 <code>Gossip</code>协议相互交互集群信息，最后每个节点都保存着其他节点的 slots 分配情况。</p>
<h2 id="Cluster实现原理"><a href="#Cluster实现原理" class="headerlink" title="Cluster实现原理"></a>Cluster实现原理</h2><p>Redis 3.0 开始，官方提供了 Redis Cluster 方案实现了切片集群，该方案就实现了数据和实例的规则。Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。</p>
<h3 id="将数据分成多份存在不同实例上"><a href="#将数据分成多份存在不同实例上" class="headerlink" title="将数据分成多份存在不同实例上"></a>将数据分成多份存在不同实例上</h3><p>集群的整个数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。</p>
<p>Key 与哈希槽映射过程可以分为两大步骤：</p>
<ol>
<li>根据键值对的 key，使用 CRC16 算法，计算出一个 16 bit 的值；</li>
<li>将 16 bit 的值对 16384 执行取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽。</li>
</ol>
<p>Cluster 还允许用户强制某个 key 挂在特定槽位上，通过在 key 字符串里面嵌入 tag 标记，这就可以强制 key 所挂在的槽位等于 tag 所在的槽位。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9ACluster%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/" data-id="clktuzzgz004ncdoo664gf6eg" data-title="Redis高可用篇：Cluster 集群原理" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis高可用篇：主从同步原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/">Redis高可用篇：主从同步原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Redis具有高可用行，高可用有两层含义：一是数据尽量少丢失，二是服务尽量少中断。AOF和RDB保证了前者，对于后者，redis的做法就是增加副本冗余量，将一份数据同时保存在多个实例上，即使有一个实例出现了故障，需要一段时间才能恢复，其他的实例也可以对外提供服务，不会影响业务使用。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的就是<strong>读写分离</strong>的方式。</p>
<ul>
<li>读操作：主库、从库都可以接收；</li>
<li>写操作：首先到主库执行，然后，主库将写操作同步给从库。</li>
</ul>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.png" alt="redis主从复制的读写分离"></p>
<p>如果主从库都能接收客户端的写操作，就会导致主从库的数据不一致，除非使用加锁等操作，但是加锁会带来巨额的开销。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/" data-id="clktuzzh1004qcdoof5wkf3g4" data-title="Redis高可用篇：主从同步原理" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag">高可用</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/Redis高可用篇：哨兵集群原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9A%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9A%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/">Redis高可用篇：哨兵集群原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>主从复制是高可用的基石，从库宕机依然可以将请求发送给主库或者其他从库，但是 Master 宕机，只能响应读操作，写请求无法再执行。所以主从复制架构面临一个严峻问题，<strong>主库挂了，无法执行「写操作」，无法自动选择一个 Slave 切换为 Master</strong>，也就是无法<strong>故障自动切换</strong>。为此，Redis 官方提供一个高可用方案——<strong>哨兵（Sentinel）</strong>。</p>
<h2 id="哨兵的任务"><a href="#哨兵的任务" class="headerlink" title="哨兵的任务"></a>哨兵的任务</h2><p>搭建实例采用三个哨兵形成集群，三个数据节点（一主两从）方式搭建，如下图所示：</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/Redis%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4.png" alt="Redis哨兵集群"></p>
<p>哨兵是 Redis 的一种运行模式，它专注于<strong>对 Redis 实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性</strong>。Redis 哨兵具备的能力有如下几个：</p>
<ul>
<li><strong>监控</strong>：持续监控 master 、slave 是否处于预期工作状态。</li>
<li><strong>自动切换主库</strong>：当 Master 运行故障，哨兵启动自动故障恢复流程：从 slave 中选择一台作为新 master。</li>
<li><strong>通知</strong>：让 slave 执行 replicaof（复制），与新的 master 同步；并且通知客户端与新 master 建立连接。</li>
</ul>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%93%A8%E5%85%B5%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%9B%AE%E6%A0%87.png" alt="redis哨兵执行任务与目标"></p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>Sentinel 通过以每秒一次的频率向所有 Master、Slave、其他 Sentinel 发送 PING 命令，如果 slave 没有在在规定时间内响应「哨兵」的 PING 命令，「哨兵」就认为它挂掉了，就会将他记录为「下线状态」；假如 master 没有在规定时间响应 「哨兵」的 PING 命令，哨兵就判定master下线，开始执行「自动切换 master 」的流程。</p>
<p>PING 命令的回复有两种情况：</p>
<ol>
<li>有效回复：返回 +PONG、-LOADING、-MASTERDOWN 任何一种；</li>
<li>无效回复：有效回复之外的回复，或者指定时间内返回任何回复。</li>
</ol>
<p>为了防止误判master挂掉，「哨兵」设计了「主观下线」和「客观下线」两种暗号。</p>
<ol>
<li>主观下线：如果回复是无效回复，哨兵会把master标记为主观下线，如果检测的是slave，哨兵直接标记为主观下线，因为主库还在，从库挂掉影响不大。</li>
<li>客观下线：<strong>判断 master 是否下线不能只有一个「哨兵」说了算，只有一定数量（通过配置文件配置）的哨兵判断 master 已经「主观下线」，这时候才能将 master 标记为「客观下线」</strong>。</li>
</ol>
<p>只有 master 被判定为「客观下线」，才会进一步触发哨兵开始主从切换流程。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%93%A8%E5%85%B5%E7%9A%84%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF.png" alt="redis哨兵的客观下线"></p>
<h3 id="自动切换主库"><a href="#自动切换主库" class="headerlink" title="自动切换主库"></a>自动切换主库</h3><p>「哨兵」的第二个任务，选择新 master 。需要从slave中按照一定规则选择一个合适的从库作为主库。按照一定的 <strong>「筛选条件」 + 「打分」</strong> 策略，选出master。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E6%96%B0master%E9%80%89%E6%8B%A9.png" alt="redis新master选择"></p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>最后一个任务，「哨兵」将新 「master 」的连接信息发送给其他 slave，并且让 slave 执行 replacaof 命令，和新「master 」建立连接，并进行数据复制。</p>
<p>除此之外，「哨兵」还需要将新master的连接信息通知客户端，使得让所有将读写请求转移到新 master。</p>
<h2 id="哨兵集群工作原理"><a href="#哨兵集群工作原理" class="headerlink" title="哨兵集群工作原理"></a>哨兵集群工作原理</h2><p>哨兵部门并不是一个人，多个人共同组成一个哨兵集群，哨兵之间可以相互通信，主要归功于 Redis 的 <code>pub/sub</code> 发布&#x2F;订阅机制。</p>
<p>master 有一个 <code>__sentinel__:hello</code> 的专用通道，用于哨兵之间发布和订阅消息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口，从而相互发现建立连接。</p>
<p>如下图所示，哨兵 2 向 Master 发送 <code>INFO</code> 命令，Master 就把 slave 列表返回给哨兵 2，哨兵 2 便根据 slave 列表连接信息与每一个 slave 建立连接，并基于此连接实现持续监控。剩下的哨兵也同理基于此实现监控。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/redis%E5%93%A8%E5%85%B5%E4%B8%8Emaster%E4%BB%A5%E5%8F%8Aslave%E8%BF%9E%E6%8E%A5%E5%9B%BE.png" alt="redis哨兵与master以及slave连接图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AF%87%EF%BC%9A%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86/" data-id="clktuzzh2004tcdoo0fmh0vnn" data-title="Redis高可用篇：哨兵集群原理" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%A8%E5%85%B5/" rel="tag">哨兵</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag">高可用</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-中间件/Redis/用Redis的数据结构实现亿级数据统计" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E7%94%A8Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" class="article-date">
  <time class="dt-published" datetime="2023-08-02T15:04:31.404Z" itemprop="datePublished">2023-08-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E7%94%A8Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/">用Redis的数据结构实现亿级数据统计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>在移动应用的业务场景中，我们需要保存这样的信息：一个 key 关联了一个数据集合。</p>
<p>常见的场景如下：</p>
<ul>
<li>给一个 userId ，判断用户登陆状态；</li>
<li>显示用户某个月的签到次数和首次签到时间；</li>
<li>两亿用户最近 7 天的签到情况，统计 7 天内连续签到的用户总数；</li>
<li>统计每天的新增与第二天的留存用户数；</li>
<li>统计网站的对访客（Unique Visitor，UV）量</li>
<li>最新评论列表</li>
<li>根据播放量音乐榜单</li>
</ul>
<p>通常情况下，我们需要统计的数据过大，通常达到百万，甚至过亿，所以必须选择能高效地统计大量数据的集合类型。</p>
<p><strong>如何选择合适的数据集合，我们首先要了解常用的统计模式，并运用合理的数据类型来解决实际问题。</strong>四种统计类型如下：</p>
<ol>
<li>二值状态统计；</li>
<li>聚合统计；</li>
<li>排序统计；</li>
<li>基数统计。</li>
</ol>
<h2 id="二值状态统计"><a href="#二值状态统计" class="headerlink" title="二值状态统计"></a>二值状态统计</h2><p>基于上述的业务场景，统计的数据，比如用户登录状态，只有两种状态（登录和非登录），分别对应的是1和0，所以适合使用Bitmap数据结构实现二值状态统计。比如登陆状态我们用一个 bit 位表示，一亿个用户也只占用 一亿 个 bit 位内存 ≈ （100000000 &#x2F; 8&#x2F; 1024&#x2F;1024）12 MB。</p>
<h3 id="Bitmap底层结构"><a href="#Bitmap底层结构" class="headerlink" title="Bitmap底层结构"></a>Bitmap底层结构</h3><p>Bitmap 的底层数据结构用的是 String 类型的 SDS 数据结构来保存位数组，Redis 把每个字节数组的 8 个 bit 位利用起来，每个 bit 位 表示一个元素的二值状态（不是 0 就是 1）。</p>
<p>可以将 Bitmap 看成是一个 bit 为单位的数组，数组的每个单元只能存储 0 或者 1，数组的下标在 Bitmap 中叫做 offset 偏移量。</p>
<p><img src="https://gitee.com/hu-zhihong/picbed/raw/master/Bitmap%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="Bitmap底层结构图"></p>
<h3 id="业务场景一：判断用户登录状态"><a href="#业务场景一：判断用户登录状态" class="headerlink" title="业务场景一：判断用户登录状态"></a>业务场景一：判断用户登录状态</h3><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;	//设置或者清空 key 的 value 在 offset 处的 bit 值（只能是 0 或者 1）。</span><br><span class="line">getbit &lt;key&gt; &lt;offset&gt;	//获取 key 的 value 在 offset 处的 bit 位的值，当 key 不存在时，返回 0。</span><br></pre></td></tr></table></figure>

<p>login_status作为登录的key，用户ID作为offset，登录状态用value表示，登录则调用<code>setbit login_status 10086 1</code>把用户10086的value设为1，检查该用户是否登录则调用<code>getbit login_status 10086</code>，判断返回值为多少。</p>
<h3 id="业务场景二：用户每个月的签到情况"><a href="#业务场景二：用户每个月的签到情况" class="headerlink" title="业务场景二：用户每个月的签到情况"></a>业务场景二：用户每个月的签到情况</h3><p>一个月最多有31天，最多只需要31个bit位，可以把Bitmap的key设计成<code>uid:sign:&#123;userId&#125;:&#123;yyyyMM&#125;</code>，月份的每一天的值 - 1可以作为offset（因为offset从0开始）。</p>
<p>如统计用户10086在2021年6月份的打卡情况，执行步骤如下：</p>
<p>第一步，执行<code>setbit uid:sign:10086:202106 16 1</code>，记录用户10086在2021年6月16日的打卡情况；</p>
<p>第二步，统计该用户在 6 月份的打卡次数，使用 <code>BITCOUNT</code> 指令。该指令用于统计给定的 bit 数组中，值 &#x3D; 1 的 bit 位的数量，<code>bitcount uid:sign:10086:202106</code>。</p>
<p>再例如统计这个月首次打卡时间：</p>
<p>此外，Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。在默认情况下， 命令将检测整个位图， 用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。</p>
<p>执行<code>bitpos uid:sign:10086:2021056 1</code>，得到用户10086在2021年6月首次打卡的时间，注意，这个事件需要加上1，因为offset是从0开始的。</p>
<h3 id="业务场景三：连续签到用户总数"><a href="#业务场景三：连续签到用户总数" class="headerlink" title="业务场景三：连续签到用户总数"></a>业务场景三：连续签到用户总数</h3><p>例如在记录了一个亿的用户连续 7 天的打卡数据，如何统计出这连续 7 天连续打卡用户总数呢？</p>
<p>思路分析：把每一天的打卡数据都设计成一个key，userid作为offset，key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。连续7天则表示，即有7个类型为Bitmap的key，同样的 UserID  offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p>
<p>Redis 提供了 <code>bittop operation destkey key [key ...]</code>这个指令用于对一个或者多个 键 &#x3D; key 的 Bitmap 进行位元操作。<code>opration</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。<code>destkey</code>是进行位元操作后新生成的key。</p>
<p>第一步：执行<code>bittop and destkey 20210615 20210616 20210617 ....</code>把7个key进行按位与操作；</p>
<p>第二步：使用命令<code>bitcount destkey</code>统计destkey中1的个数，即为连续7天签到的用户数量。</p>
<h2 id="聚合统计"><a href="#聚合统计" class="headerlink" title="聚合统计"></a>聚合统计</h2><p>指的就是统计多个集合元素的聚合结果，比如说：</p>
<ul>
<li>统计多个元素的共有数据（交集）；</li>
<li>统计两个集合其中的一个独有元素（差集统计）；</li>
<li>统计多个集合的所有元素（并集统计）。</li>
</ul>
<p>Redis 的 Set 类型支持集合内的增删改查，底层使用了 Hash 数据结构，无论是 add、remove 都是 O(1) 时间复杂度。并且支持多个集合间的交集、并集、差集操作，利用这些集合操作，解决上边提到的统计问题。</p>
<h3 id="业务场景一：共同好友（交集）"><a href="#业务场景一：共同好友（交集）" class="headerlink" title="业务场景一：共同好友（交集）"></a>业务场景一：共同好友（交集）</h3><p>比如 QQ 中的共同好友正是聚合统计中的交集。我们将账号作为 Key，该账号的好友作为 Set 集合的 value。</p>
<p>执行步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sadd user1 A B C</span><br><span class="line">sadd user2 B C D</span><br><span class="line">sinterstore user:共同好友 user1 user2	//统计user1与user2的共同好友，结果是B和C</span><br></pre></td></tr></table></figure>



<h3 id="业务场景二：每日新增的数量（差集）"><a href="#业务场景二：每日新增的数量（差集）" class="headerlink" title="业务场景二：每日新增的数量（差集）"></a>业务场景二：每日新增的数量（差集）</h3><p>比如，统计某个 App 每日新增注册用户量，只需要对近两天的总注册用户量集合取差集即可。</p>
<p>比如，2021-06-01 的总用户量存放在 <code>key = user:20210601</code> set 集合中，2021-06-02 的总用户量存放在 <code>key = user:20210602</code> 的集合中。</p>
<h3 id="业务场景二：总共新增好友（并集）"><a href="#业务场景二：总共新增好友（并集）" class="headerlink" title="业务场景二：总共新增好友（并集）"></a>业务场景二：总共新增好友（并集）</h3><p>还是差集的例子，统计 2021&#x2F;06&#x2F;01 和 2021&#x2F;06&#x2F;02 两天总共新增的用户量，只需要对两个集合执行并集。</p>
<p>使用命令：<code>SUNIONSTORE userid:new user:20210602 user:20210601</code>，此时新的集合 userid:new 则是两日新增的好友。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。</p>
<p>所以，可以专门部署一个集群用于统计，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避由于阻塞导致其他服务无法响应。</p>
<h2 id="排序统计"><a href="#排序统计" class="headerlink" title="排序统计"></a>排序统计</h2><p>Redis 的 4 个集合类型中（List、Set、Hash、Sorted Set），List 和 Sorted Set 就是有序的，Sorted Set 类型占用的内存容量是 List 类型的数倍之多，所以尽量使用list，对于列表数量不多的情况，可以用 Sorted Set 类型来实现。</p>
<ul>
<li>List：按照元素插入 List 的顺序排序，使用场景通常可以作为 消息队列、最新列表、排行榜；</li>
<li>Sorted Set：根据元素的 score 权重排序，我们可以自己决定每个元素的权重值。使用场景（排行榜，比如按照播放量、点赞数）。</li>
</ul>
<h3 id="业务场景一：最新评论列表"><a href="#业务场景一：最新评论列表" class="headerlink" title="业务场景一：最新评论列表"></a>业务场景一：最新评论列表</h3><p>每当一个用户评论，则利用 <code>LPUSH key value [value ...]</code> 插入到 List 队头。接着再用 <code>LRANGE key star stop</code> 获取列表指定区间内的元素。但是如果是频繁更新的列表，list类型的分页可能导致列表元素重复或者漏掉。</p>
<p>只有不需要分页（比如每次都只取列表的前 5 个元素）或者更新频率低（比如每天凌晨统计更新一次）的列表才适合用 List 类型实现。对于需要分页并且会频繁更新的列表，需用使用有序集合 Sorted Set 类型实现。</p>
<h3 id="业务场景二：排行榜"><a href="#业务场景二：排行榜" class="headerlink" title="业务场景二：排行榜"></a>业务场景二：排行榜</h3><p>比如要一周音乐榜单，我们需要实时更新播放量，并且需要分页展示。除此以外，排序是根据<strong>播放量</strong>来决定的，这个时候 List 就无法满足了。</p>
<p>实现步骤如下：</p>
<p>第一步，首先通过命令<code>zadd musicTop 100000000 青花瓷 8999999 花田错</code>将歌曲以及它对应的播放量添加到set里。</p>
<p>第二步：歌曲每播放一次，就通过命令<code>zincrby musicTop 1 青花瓷</code>将歌曲对应的分数+1。</p>
<p>第三步：最后我们需要获取 musicTop <strong>前十</strong>播放量音乐榜单，目前最大播放量是 N ，可通过如下指令获取：<code>zrangebyscore musicTop N-9 N WITHSCORES</code>。N获取方式是通过<code>zrevrange key start stop [WITHSCORES]</code>指令。其中元素的排序按 <code>score</code> 值递减(从大到小)来排列，如<code>ZREVRANGE musicTop 0 0 WITHSCORES</code></p>
<h2 id="基数统计"><a href="#基数统计" class="headerlink" title="基数统计"></a>基数统计</h2><p>基数统计：统计一个集合中不重复元素的个数，常见于计算独立用户数（UV）。</p>
<p>Redis 提供了 <code>HyperLogLog</code> 数据结构就是用来解决种种场景的统计问题。</p>
<p><code>HyperLogLog</code> 是一种不精确的去重基数方案，它的统计规则是基于概率实现的，标准误差 0.81%，这样的精度足以满足 UV 统计需求了。</p>
<p>关于 HyperLogLog 的原理过于复杂，如果想要了解的请移步：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53416615">https://www.zhihu.com/question/53416615</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HyperLogLog">https://en.wikipedia.org/wiki/HyperLogLog</a></li>
</ul>
<h3 id="业务场景：统计网站的UV"><a href="#业务场景：统计网站的UV" class="headerlink" title="业务场景：统计网站的UV"></a>业务场景：统计网站的UV</h3><p>方案一：采用集合（<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU3NDkwMjAyOQ==&mid=2247485665&idx=1&sn=3cf8e45aaa071fa26975bca34b8878e4&chksm=fd2a1283ca5d9b95889dbc3ec5949f784f6b8e6b469e49675731a8a544321fc4633058e27c41&scene=21#wechat_redirect">Set</a>）这种数据结构，set中不允许有重复的value，网站名作为key，用户作为value，当插入（sadd）新的元素时，set中的个数增加，当插入重复元素时，set中的个数不变，最后通过<code>scard</code>命令统计元素个数，但是当访问量巨大，就需要一个超大的Set集合，将会浪费大量空间。</p>
<p>方案二：还可以利用 Hash 类型实现，将用户 ID 作为 Hash 集合的 key，访问页面则执行 HSET 命令将 value 设置成 1。</p>
<p>方案三：使用Redis 提供的 <code>HyperLogLog</code> 高级数据结构，每个 <code>HyperLogLog</code> 最多只需要花费 12KB 内存就可以计算 2 的 64 次方个元素的基数。Redis 对 <code>HyperLogLog</code> 的存储进行了优化，在计数比较小的时候，存储空间采用稀疏矩阵，占用空间很小。只有在计数很大，稀疏矩阵占用的空间超过了阈值才会转变成稠密矩阵，占用 12KB 空间。</p>
<p>使用步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PFADD Redis数据 user1 user2 user3	//往HyperLogLog中添加信息</span><br><span class="line">PFADD MySQL数据 user1 user2 user4</span><br><span class="line">PFMERGE 数据库 Redis数据 MySQL数据	//合并两个HyperLogLog对象</span><br><span class="line">PFCOUNT 数据库 // 返回值 = 4	//统计新的HyperLogLog对象的个数</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/%E7%94%A8Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%E4%BA%BF%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1/" data-id="clktuzzh6004vcdoo0k4d09io" data-title="用Redis的数据结构实现亿级数据统计" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GO/">GO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySql/">MySql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/k8s/">k8s</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E9%9B%85%E5%86%99%E4%BD%9C/">优雅写作</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BC%98%E9%9B%85%E5%86%99%E4%BD%9C/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">图床搭建</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/">全文搜索引擎</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BitMap/" rel="tag">BitMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/map/" rel="tag">map</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/" rel="tag">vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%A8%E5%85%B5/" rel="tag">哨兵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" rel="tag">负载均衡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="tag">高可用</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/BitMap/" style="font-size: 10px;">BitMap</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/C-11/" style="font-size: 10px;">C++11</a> <a href="/tags/MySql/" style="font-size: 13.33px;">MySql</a> <a href="/tags/Redis/" style="font-size: 20px;">Redis</a> <a href="/tags/docker/" style="font-size: 13.33px;">docker</a> <a href="/tags/go/" style="font-size: 16.67px;">go</a> <a href="/tags/k8s/" style="font-size: 13.33px;">k8s</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/map/" style="font-size: 10px;">map</a> <a href="/tags/vector/" style="font-size: 10px;">vector</a> <a href="/tags/%E5%93%A8%E5%85%B5/" style="font-size: 10px;">哨兵</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 16.67px;">算法</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 10px;">负载均衡</a> <a href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/" style="font-size: 13.33px;">高可用</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/02/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/">nginx</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/Reactor%20%E5%92%8C%20Proactor/">Reactor 和 Proactor</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a>
          </li>
        
          <li>
            <a href="/2023/08/02/%E5%90%8E%E7%AB%AF/%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/">项目代码分层结构</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 pepper<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>